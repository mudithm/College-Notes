<h1>Lab 4</h1>

---

<h5>Java</h5>

  * All objects in java are passed by reference
  * For an inherited object, you can only assign a variable of a certain type to a value that is higher in the inheritance tree
```java
class Shape(){
    void draw() {};
}

class Square() extends Shape{
    void draw() {/* Draw square */}
}

//.........

{
    Square b = new Square(); 
    Shape a = b; // allowed

    Shape c = new Shape();
    Square d = c; // not allowed, since the compiler doesn't know if Square needs defs that Shape doesn't have

    Shape e = new Square();
    Square f = e; // not allowed, since the compiler doesn't know that e is a square

    // This can be overcome through explicit type casting, but this would cause a runtime error if the shape was not a square.
}
```

  * Multiple inheritance is not allowed in Java, since there could be conflicting method definitions

---

<h5>Interfaces</h5>

  * Defines what a class must contain, (functinos, etc) but doesn't define them

```java
    interface Vehicle {
        void drive();
        float weight;
        float price;
    }

    class Car extends Vehicle {
    void drive() { /* this must be defined */ };
    }
```

---

<h5>Abstract Classes</h5> 

   * Can have some functions defined, but cannot be instantiated by itself

```java
    abstract class Vehicle {
    void drive() {/* some definitions*/};
    }    

    class Car extends Vehicle {
        //can override functions, etc
    }
```

---

<h5>Access Modifiers</h5>

Given package one containing Alpha and Beta, and package two containing Alphasub and Gamma, with Alphasub being a subclass of Alpha

Visibility:
| Modifier | Alpha | Beta | Alphasub | Gamma |
| --- | --- | --- | --- | -- |
| Public | Y | Y | Y | Y |
| Protected | Y | Y | Y | N |
| no modifier | Y | Y | N | N |
| private | Y | N | N | N |

>In general, it is best to start with private and make fields/methods more visible only when it's necessary
Classes only have two access modifiers: publi or no modifier (package private)

---

<h5>Threads</h5>

  * To create threads, you need to make a class that extends Runnable (just means it contains a function `run()`). 
  * call `start()` to start a thread, and `join()` to wait on other sibling threads and then finish

<h5>Java Memory Model</h5>

  * Different threads have their own thread stack, but they share a heap
  * Heap accesses need to be monitored to prevent race conds, etc.
  * "as-if-serial" is used with only one thread

--- 

<h5>Problems with concurrency</h5>