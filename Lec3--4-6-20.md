<h1>Lecture 3</h1>

---

<h3>Last time...</h3>

  * Parts of a database management system
  * 5 predominant data models
      - most important is relational
  * Concept of DML and DDL
      - DDL enforces relational constraints
  * Intro to Relational Model
      - Keys and Superkeys

---

<h3>Superkeys, Candidate and Primary Keys</h3>

  * Relation R has n attributes S = {a<sub>1</sub>, ... a<sub>n</sub>}
      - Same number of attributes in each tuple, in the same order
  * A superkey is a subset of attrs in R that uniquely ID's each tuple
  * the minimal superkey is the superkey that contains the fewest # of attrs
  * Primary key is a candidate key that the DB dev picks to enforce uniqueness

<h3>YouTube example</h3>

  * What is the max number of superkeys?
      - All subsets of the attributes
      - 2<sup>n</sup>-1

<h3>More Properties</h3>

  * A superkey that includes all attrs is trivial
  * if we have a superkey s and a set of attrs k, then s &union; k is also a superkey
      - still uniquely identifies tuples
  * minimal superkey is the superkey containing fewest number of attrs
      - also called candidate key
  * Primary key is candidate key that the DB dev picks to enforce uniqueness
      - Candidate keys can be `null`, primary keys cannot

<h3>Alg for identifying superkeys</h3>

  * For a small relation, it might be easy, but if you're undure, use the following alg
      - computes all subsets of attrs
      - eliminate any that fail the superkey def
          + do not uniquely identify tuples
      - The set we are left with is the set of superkeys; at least one will also be a candidate key

---

<h3>Back to Youtube Videos and Comments</h3>

  * video_id is a candidate/primary key for the videos relation 
  * comment_it is a candidate/primary key for the comments relation
  * What if we change the encoding of the comments relation?
      - Instead of having a unique comment_id, we use the video id and a sequence # (still called comment_id) to uniquely identify typles
          + This would be the new candidate key

---

<h3>Foreign Key</h3>

 * `Foreign key` is an attribute of R that is the primary key of some relation R'
 * Loosely:
     - attr that can be used to tie together related typles of two relations
     - foreign key in R may not uniquely identify a tuple in R, but does in the referred relation R'
 * R and R' are _related_ by this foreign key
 * Can be composites of multiple attributes
     - All attributes that make up the foreign key must be in both R and R'
 * Foreign key is in the referring table, referencing an entry in the referenced table

<h3>Foreign keys are used for Referential Integrity</h3>

  * If we add a new comment to the comments relation, it needs to be posted on a video that exists in the videos relation
  * This relationship allows the RDBMS to protect against data loss
      - If we try to delete a video that has comments, we don't want those comments to remain orphaned in the comments relation
          + RDMBS should give an error
  * In other words, foreign keys in a relation R are used to protect data in R from being orphaned or inconsistent

---

<h3>Representing a Schema Visually: Word Soup <b>IMPORTANT FOR MIDTERM/FINAL</b></h3>
  * Relations, attrs and keys are represented visually in a diagram

---

<h2>Relational Algebra</h2>

---

<h3>Relational Operators</h3>

  * Selection (&sigma;)
  * Projection (&Pi;)
  * Cartesian Product (x)
  * Natural join and Theta Join
  * St union (&cup;)
  * Set difference (-) and Set intersection (&cap;)
  * Rename (&rho;)
  * Aggregation (&gamma; or G)

---

<h3>Selection &sigma;</h3>

  * Retrieves a subset of tuples from a single relation
      - satisfies a particular constraint and returns a new relation which is a subset of the original
  * predicate (&psi;) compares two attributes, or an attribute and a value, using a binary operator
  * We can also use attributes on both sides of a binary operator
      - likes > dislikes
      - cat_id = 17
  * We can also build up more complex predicates using conjunction (and) and disjunction (or)
      - &and; and &or; for these, not &cap; and &cup;
  * Example SQL implementation:

```sql
SELECT *
FROM youtube_videos
WHERE likes > dislikes
AND views > 1000000
AND cat_id = 24
```

  * The where clause (last three lines) is a selection statement, where the predicate is `(likes > dislikes> &and; (views > 1000000) &and; (cat_id = 24)`
  * In the prev example, we used the * so that the database returns all columns of a particular table
  * What if we only wanted to choose the title column?
      - We can't do it yet! Selection in relational attribute works only on entire tuples
      - **IMPORTANT: &sigma; IS THE WHERE CLAUSE, NOT THE SELECT QUERY**
      - **&sigma; &ne; SQL SELECT**

---

<h3>Projection</h3>

  * extracts attributes from a set of tuples, and removes duplicate tuples
  * given a relation R and tuple t, and a subset of attrs a<sub>1</sub>, ... a<sub>n</sub>
      - math here
  * Extracting an attribute, ie title, is done as a projection
  * Projection is typically the last (outermost) operation done in a relation before we are done with it
  * Can be generalized to create new attributes or rename attrs using the &rarr; notation
      - Apply arbitrary expressions to existing attrs
      - Apply arbitrary expressions to existing columns to create another one
      - Rename attributes
  * If we want to choose ALL attributes, as in `SELECT *` we just use the select operator and not the projection operator


<h3>Combining &sigma; and &Pi;</h3>

  * Just like in mathematics and logic, we will usually want to combine expressions
  * Ex: write a query to extracft the title and channel for all videos that have more than 1 million views and more likes than dislikes

```sql
SELECT
    title,               | Projection
    channel              |
FROM
    youtube_videos
WHERE
    likes > dislikes      |
    and                   |  Selection
    views > 1000000       |
```

   * Obv, there are more than one correct answer to doing this
       - chaining selects, etc

---

<h3>Cartesian Product X</h3> 

  * combines tuples from two relations, in all possible combinations of tuples
  * Cartesian product is neither commutative nor associative
  * Why would we ever want to perform a Cartesian product with real data?
      - We rarely need all pairs
  * Cartesian products by themselves are very slow to compute, require a lot of RAM, and a lot of disk space
  * We use this to motivate the discussion of a join
  * Failing to filter on a cross product (or Cross Join) is really bad


---

<h3>Natural Join</h3> 

  * We do a join when we have 2 separate relations and we need records/tuples from both to form a single combined (joined) record
  * given two relations R<sub>1</sub> and R<sub>2</sub>, a join creates a new relation S by matching tuples from both relations that both satisfy some condition
  * The simplest in the relational algebra is the natural join, which allows us to join two relations together based on equality , using common attribute names
      - RDBMS implicitly chooses the join key and applies the equality operator
  * What happens if you try a natural join between relations that have no common attributes?
      - You get a Cartesian product of the two
  * What if we *do* have common attributes, but no common values?
      - You get the empty set
  * We can also do this for more than two relations
  * Also, natural joins are associative
