<h1>Lecture 3</h1>

---

<h2>Complexity</h2>

---

<h3>Probabilities</h3>

  * PPT: probabalistic Polynomial-Time
  * probable events happen with poly probability
  * __F3.1__
      - Events with a polynomial probability are expected to occur if we run an alg poly times
      - We want a function such that the probability is so low that this cannot occur
      - Negligible function: f(n) is negligible if it is less than 1/n<sup>c</sup> for all c, for a large enough n
  * Formal definition:  

>f(n) is negligible if
  <br>&nbsp;&nbsp;&nbsp; &forall; n &ge; N_c  (N_c is some constant, different for the c)
  <br>&nbsp;&nbsp;&nbsp; f(n) &lt; 1/n^c

  * As an algorithm gets harder and harder, the adversary's probability of success gets progressively smaller, and if we choose a large enough n (ie key size, etc) there will always be a negligible possiblity of the adversary succeeding
  * N_c describes the threshold for n, below which a function might be guessed and above which the function is extremely unlikely to be (for a negligible function, such an N_c exists for every poly alg (n^c)) 

<h3>Negligible Functions</h3>

  * NOT negligble functions:
      - Polynomial functions
      - Functions with constant to the log
  * Negligible functions
      - Inverse exponential (without log)
      - Any function that converges to zero faster than poly-time as n increases (inverse of a super-poly)

---

<h3>Non-uniform poly-time</h3>
  
  * __F3.3__ 
  * Normal algorithms:
      - ie sort(a<sub>1</sub>, a<sub>2</sub>, ... a<sub>n</sub>) works the exact same way as sort(a<sub>1</sub>, a<sub>2</sub>, ... a<sub>n^2</sub>)
  * In hardware, we might break such a problem into smaller chunks to perform the same sort
      - build a circuit in hardware that performs different functions depending on the number of inputs
  * P/poly (non-uniform polytime0)
      - If there exists an infinite sequence of circuits for any () length that correctly decided L s.t. size of this circuit is poly-bounded
      - Poly-time computation with poly-size advice
          + advice -- given a circuit of size n^c for some fixed c, given by "god", then you can efficiently compute the decision (whether or not it is in the language)
  * Non-uniform bc the alg (or circuit) depends on the number of inputs, where the size is bounded by n^c
  * Note: p/poly is NOT a subset of NP.
      - Given some circuit c, how do we know that the circuit doesn't make a mistake on some input
      - We don't know how to check s
      - P/poly can compute undecidable languages
          + meaning
  * Adelman: BPP is a subset of P/Poly
      - Bounded-error Probabilistic Polynomial-time
      - Tells us that if there exists an alg that is correct >2/3 of the time on all instances (BPP), using randomness, then an alg exists that doesn't need randomness, and which never makes a mistake.
  * Proof
      - __F3.4__
      - 1. Error reduction can be done to reduce error below these bounds (1/2<sup>n+1</sup>)
      - 2. There exists some magic "r" that will work for every x, and will never make a mistake
          + Look at [this proof](https://cs.stanford.edu/~trevisan/cs254-10/lecture04.pdf)

---

<h2>One Way Functions</h2>

---

<h3><b>F3.5</b></h3>

  * a function as described above is a one-way function if the probability of wining is negligible for ALL PPT adversaries.
  * f is a one-way function if
      - f is poly-time computable
      - The input and output of f are poly-time related
          + if the size of input and input are very different, polynomial time for the adversary may be very different than poly-time for the challenger
          + we want the output to be around size (n<sup>&epsilon;</sup> (polynomially related)
      - Any PPT adversary inverts f with only negligible probability
          + The probability that, for some challenger-response game, given that the challenger picks x at random and the challenger picks x' at random, for large enough n (larger than some N_c) the probability of the adversary of guessing the correct x' is negligible.


---

<h3>Teaser</h3>

  * Suppose two friends want to play a game: they flip a coin, if it's heads one pays the other $100, and if it's tails, vice versa.
  * __F3.5__
  * How can Alice and Bob trust that the other is not lying about their flip?
      - Or rather, how can they play this game and know for sure that neither Bob nor Alice are cheating?