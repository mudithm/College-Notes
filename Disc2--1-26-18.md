<h1>Discussion 2</h1>

---

Linked lists are typically defined using dynamically allocated variables (not local variables)

For example: 

```c++

// The Node struct will be defined as below for the remainder of this section
struct Node{

    int value;
    Node* link;

};

int main(){
    Node* head;
    Node meme, meme1, meme2;
    
    head = &meme;
    meme.value = 5;
    meme.link = &meme1;

    meme1.value = 6;
    meme1.link = &meme2;
    
    meme3.value = 7;
    meme2.link = nullptr;    
}
```

This code works, but is rather inconvenient to use, since you have to explicitly initialize each node before execution.

A better solution uses dynamic allocation.

```c++

int main(){

    Node* head = new Node;
    Node* temp = head;

    temp->value = 1;
    temp->link= new Node;
    temp = temp->link;

    temp->value = 2;
    temp->link = new Node;
    temp = temp->link;

    temp->value = 3;
    temp->link = nullptr;

}
```

But even this implementation has its drawbacks, as you have to repeat a bunch of code every time you create a new node. If we define a  class  to handle these operations, we can make use of member functions to make our code less repetitive.

```c++

Class LinkedList{
    const int END = 0;
    const int BEG = 1;
    public:
        LinkedList();
        ~LinkedList();
        void addNode(int value, int pos = 0);
        void remNode(int value);
        int size();
        void display();
        bool search(int meme);
    private:
        int size;
        Node* head;
};

```

If we begin with the `insert` function, we have to think of all the possible cases:
Insert at:

  * Beginning
  * End
  * Somewhere in the Middle
  * Beginning of empty list

Implementation:

```c++

LinkedList::LinkedList(){
    size = 0;
    head = new Node;
    head->link = nullptr;
}

void LinkedList::display(){
    for (Node* p = head; p != nullptr; p = p->link)
        cout << p->value << endl;
}

void LinkedList::addNode(int val, int pos){
    
    if (head == nullptr){
        head = new Node;
        head->value = val;
        head->link = nullptr;
        return;
    }
    
    switch (pos){
        case 0:
            for (Node* temp = head; temp->link != nullptr; temp = temp->link)
                ;
            temp->link = new Node;
            temp = temp->link;
            temp->value = val;
            temp->link = nullptr;
            size++;
            break;
        case 1:
            Node* temp = new Node;
            temp->value = val;
            temp->link = head;
            head = temp;
            size++;
            break;
        default:
             if (pos < 0 || pos >= size()){
                cout << "Cannot add node at position " << pos << endl;
                exit(0);
            }
            int i = 0;
            for (Node* temp = head; i < pos; temp = temp->link)
                i++;
            Node* temp2 = temp->link;
            temp->link = new Node;
            temp = temp->link;
            temp->value = val;
            temp->link = temp2;
    }

}
