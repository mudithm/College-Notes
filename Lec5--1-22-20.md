<h1>Lecture 5</h1>

---

<h5>Providing Robust DNS service</h5>

  * Robust service = high availability against network or server failures
  * two basic means: redundancy and caching
      - caching: creating reduntant data copies
  * Redundancy: replicating authoritative servers
  * Caching resolvers save a copy of all query replies
      - Authoritative servers attach a TTL value to each reply
      - cache entries are deleted after a timeout
  * Observation: caching resolvers typically have cached information of TLD servers, thus don't visit root server often

 <h5>TTL and flow balancing</h5> 

   * Some sites make sure that a specific address doesn't stay in a DNS server for very long
       - So that another person will not be routed to the same address by the same name
   * can also be user to handle server crashes

<h5>Root servers</h5>

  * While most domain name servers are hosted for profit, etc, the root servers are not. 
  * The root servers are provided for free by many orgs including the US Army, the DOD, VeriSign, and many other people
  * There are only 13 unique addresses for the DNS root servers
      - There are many more servers; many of them use the same addresses, and are indistinguishable from the perspective of a user (just different paths to the same address)
      - This is called "anycast"

---

<h4>DNS Protocol</h4>

<h5>DNS Records</h5>

  * `Resource Record` (RR) format: (name, TTL, class, type, data)
      - `class` is almost always `IN`, for internet
  * `type` = A (AAAA)
      - `name` is hostname
      - `value` is ipv4 (or v6) address
  * `type` = NS
      - `name` is a domain
      - `value` is hostname of authoritative name server for this domain
  * `type` = CNAME
      - `name` is an alias for some 'canonical' (the _real_) name
          + `wwwibm.com` is really `servereast.backup2.ibm.net` 
  * `type` = MX
      - `value` is the mailserver associated with `name`

```
name = cs.ucla.edu
data = {10,
        mailman.cs.ucla.edu
type = MX
ttl = 172800
```

---

<h5>Exploring DNS</h5>

  * `dig` -- in MacOS and Linux
  * gives dns information about a domain name (IP address, authoritative servers, and the authoritative DNS server addresses)

---

<h4>Transport Layer</h4>

  * Provide *logical communication* between app processes
  * Transport protocols run in end systems
      - sender: breaks app data into segments, passes to the network layer
      - receiver: reassembles segments, passes to app layer
  * Multiple transport protocols exist
      - most used: TCP, UDP
      - others: RTP, SCTP
      - Most Recent: QUIC

<h5>Transport vs Network Layer</h5> 

  * Transport layer: logical communication between _processes_
      - relies on, enhances, network layer services
  * Network Layer:
      - logical communicaiton between _hosts_
  * Household analogy:  
      - 12 young kids sending letters to 12 other kids
      - processes = kids
      - app messages = letters in envelopes
      - hosts = houses
      - network-layer protocal = postal service
      - transport protocol = kid's parents
          + they make sure the package gets to postal service, is deliverd, etc)

<h5>Internet transport-layer protocols</h5>

  * Reliable, in-order delivery (TCP)
      - congestion control
      - flow control
      - connection setup & tear-down
  * Unreliable, unordered delivery: UDP

---

<h5>Multiplexing/Demultiplexing</h5>

  * multiplexing at sender:
      - handle data from multiple sockets, add transport header (later used for demultiplexing)

<h5>How demultiplexing works</h5>

  * Host receives IP datagrams
      - each carries source IP add, dest IP add
      - each datagram carries one trasp-layer segmen

<h5>Connectionless Demultiplexing</h5>

  * When creating a packet to send to a UDP socket, must specify 
      - dest IP addr
      - dest port # 
  * when host receives UDP packet,
      - checks dest # 
      - directs to socket with that port # 
  * IP packets with same dest, port # are directed to the same socket at the destination host
      - they maye have diff source IP addrs and/or diff source port #s
  * How can a server know where to return a reply?
  * From UDP spec, the UDP module must be able to identify the source IP and port number from a packet

---

<h5>UDP</h5>

  * A UDP segment may be lost, duplicated, or delivered out of order
  * Connectionless:
      - no prior handshaking betw UDP sender, receiver
      - Each UDP segment handled independently of others
  * UDP used in:
      - DNS
      - Streaming multimedia apps (loss tolerant, rate sensitive)
  * If application requires reliable transfer, add reliability at application layer

<h5>UDP header format</h5>

  * Simple: performs demultiplexing only
      - no connection state at sender, receiver
  * small header size
  * no congestion control: a UDP sender can blast away as fast as it wants
  * format:
      - Source port #
      - Dest port # 
      - length (in bytes, and including the header)
      - checksum
      - application data
  * These are sent in 32 bit chunks

<h5>UDP Checksum</h5>

  * Goal: detect bit errors in transmitted segmetn
  * Sender:
      - treat segment contents as sequence of 16-bit integers
      - checksum: addition (one's comp sum) of segment contents
      - sender puts checksum value into UDP cehcksum field
  * Receiver:
      - compute checksum of received segment
      - check if computed segment checksum matches
  * THe checksum is actually computed over the _pseudoheader_, and the UDP header and data
  * Pseudoheader: 
      - protection against mis-delivered IP packets
      - Pseudo header is not carried in UDP packet, nor is it counted in teh length field
  * One can turn off the checksum by setting the checksum field to 0