<h1>Lecture 8</h1>

---

<h4>Stack Functionality</h4>
  
  * Create an empty stack
  * Push an item on the stack
  * pop an item off the stack
  * Look at the top item on the stack
  * Is the stack empty? 
  * Optional:
      - How many items are in the stack?
      - Look at any item on the stack

>The stack is sometimes called a LIFO (last in first out) data structure

The C++ standard library stack:

```c++

#include <stack>

using namespace std;

int main(){
    stack<int> s; // any type can be between the anble brackets

    s.push(10); // adds 10 to the top of the stack
    s.push(20); // adds 20 to the top of the stack
    // s.push("hello"); // This would cause an error
    int n = s.top();
    s.pop() // top item is removed, 10 is back on the top.
    if ( ! s.empty()) // 
        cout << s.size() << endl; // shows the size of the stack

}
```

>As you can see, the `stack` uses the `template` feature of the C++ language. More next week.

The stack type does not add any functionality that is not otherwise available to us; we could use a dynamically allocated array to accomplish the same thing, with even more functionality.

The reasons to use a stack are twofold: it tells the user that the data should be stored in this way, and limits the actions that can be taken on the data.

---

<h4>Data Structures: Queue</h4>

  * Create an empty queue
  * enqueue an item
  * dequeue an item
  * look at the item ad the front (head) of the queue
  * check if the queue is empty
  * Optional:
      - look at the item in the back (tail) of the queue
      - check how many items are in the queue
      - look at any item in the queue

>Queues are sometimes called a FIFO (First in, first out) data structure

The C++ Standard Library Queue:

```c++

#include <queue>

using namespace std;

int main(){
    queue<int> q;
    q.push(10); // Will enqueue the value into q
    q.push(20); // will enqueue the value into q
    int n = s.front(); // returns the value of the front item in the queue
    q.pop(); // removes the first item in the queue
    if ( ! q.empty()) // checks if queue is empty 
        cout << q.size() << endl; // returns size of queue
    int x = q.back();   // returns the last item in the queue
}

```

Unlike in other languages, the `pop()` function does not return the value it removes. This means that assigning the value at the front of a stack or queue and removing it are seperate steps.

When might a queue be used?
Here is one example, involving queries submitted to a database:

``` c++
name = 'SMITH' and (salary >= 70000 or dept = 'IT')

```

---

Examples of Function Structure

  * prefix:
      - f(x, y, z)
          + Operation comes before things that you want to do it to
      - add(sub(8, div(6/2)), 1)
          + (+ - 8 / 6 2 1)    (if each operator function is replaced by a symbol)
  * infix:
      - 6/2 (first operand 6, second 2)
      - require some additinal rules to avoid conflicts, eg 8-6/2+1 (which way?)

  * postfix:
      - 8 6 2 / - 1 +
    
To handle input in one of these forms:

  * postfix:
      - postfix
      - using a operand stack;
      - add each operand to the stack as you go by
      - if it is an operator, set operand2 to top of the operand stack and pop stack
      - set operand 1 to top of stack and pop stack
      - do the operation the operator reflects
      - push result onto stack
  * infix:
      - convert to postfix
          + operator stack
          + postfix stack
          + if operator, add to stack
          + if current operator has higher priority than prev (or open paren), push it
              * any subsequent operator to open paren has higher precedence
          + 
      - evaluate the postfix


Psuedocode for these, courtesy of Data Abstraction and Problem Solving with C++: Walls and Mirrors, 6th edition by Frank Carrano and Timothy Henry, Addison Wesley, 2013.

postfix:
```
Initialize the operand stack to empty
    For each character ch in the postfix string
        if ch is an operand
            push the value that ch represents onto the operand stack
        else // ch is a binary operator
            set operand2 to the top of the operand stack
        pop the stack
            set operand1 to the top of the operand stack
        pop the stack
        apply the operation that ch represents to operand1 and
                operand2, and push the result onto the stack
    When the loop is finished, the operand stack will contain one item,
      the result of evaluating the expression

```

Infix to Postfix Conversion:
```
Initialize postfix to empty
    Initialize the operator stack to empty
    For each character ch in the infix string
        Switch (ch)
          case operand:
            append ch to end of postfix
            break
          case '(':
            push ch onto the operator stack
            break
              case ')':
              // pop stack until matching '('
            While stack top is not '('
              append the stack top to postfix
              pop the stack
            pop the stack  // remove the '('
            break
          case operator:
            While the stack is not empty and the stack top is not '('
                    and precedence of ch <= precedence of stack top
                append the stack top to postfix
                    pop the stack
                push ch onto the stack
                break
    While the stack is not empty
        append the stack top to postfix
            pop the stack
```

Notes: postfix expressions should never have parentheses, associativity etc. are already accounted for.

---

Implementations  of Stack and Queue

Stack:

Top points to the location just after the last in the stack.
You can implement stack with either a basic array or a linked list.

```c++

class Stack{
    public:
        Stack();
        empty();
        //other functions here
    private:
        // other stuff here
};
```

