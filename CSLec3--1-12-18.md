<h1>Lecture 3</h1>

---

More code examples:

```c++
    
    //=====================================
    //Student.h
    
    #ifndef STUDENT_INCLUDED
    #define STUDENT_INCLUDED

    class Course;

    class Student{
        // ...
        void enroll(Course* cp);
        //....
        Course* m_studylist[10];

    };

    #endif // STUDENT_INCLUDED
```

```c++
    //===================================
    //Course.h

    #ifndef COURSE_INCLUDED
    #define COURSE_INCLUDED

    #include "Student.h"

    class Course{
        //...
        int units() const;
        //...
        Student* m_roster[1000];
    };
    #endif //COURSE_INCLUDED
```

```c++

    //==================================
    //myapp.cpp

    #include "Student.h"
    #include "Course.h"

    int main(){
        //....
        Student s(/* some stuff */);

    }

```


>To avoid circular dependencies, use pointers to objects instead of the objects themselves.



The above code might have been problematic if the array data members inside of each class were defined explicitly and not using pointers.

This is because the compiler needs to know the size of each variable declared and, if any member functions of an object are called, the class's definition must be seen.

Using pointers instead of objects takes care of the size requirement, because all pointers are the same size (since they just hold addresses).

However, since the above classes contained a so-called "circular dependency," because Student relies on aspects of Class and Class relies on aspects of Class, a change had to be made. Instead of including `Course.h` in the `Student` header, we just include a incomplete class declaration. Since no actual Course variables are initialized, this should work fine.

>You can have multiple incomplete declarations of a class in a compilation without issue. 

Don't include the complete header file unless you have to, instead use an incomplete class declaration.

---

__How an object is constructed:__
1. xxxxx
2. Construct the data members, consulting the member initialization list
      * If the member is listed there, construct it as indicated there.
      * If it is not listed:
          - if it's of a built-in type, leave it uninitialized
          - if it isn't of a built-in type, default construct it
3. Execute the body of the constructor


```c++

    class Circle{
        Circle (double x, double y, double r);
        double m_x;
        double m_y;
        double m_r;
    }

    Circle::Circle(double x, double y, double r) : m_x(x), m_y(y), m_r(r) {

    }
```


Default Constructor:


```c++
    
    ClassName::ClassName(){

    }

```

---


Remember that the content of a constructor is last to be consulted after the initialization list. So, if you wish to increase performance, you might use the member initialization list.


If you have a class that contains another class that has no default constructor (ie has a constructor that requires parameters), it must be initialized in the initialization list. So it's best to use the initialization list as much as possible.