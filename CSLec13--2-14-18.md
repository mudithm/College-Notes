<h1>Lecture 13</h1>
<h6>Template functions and Class Templates</h6>

---

<h4>Template Functions</h4>

```c++
int minimum(int a, int b)
{
    if (a < b)
        return a;
    else
        return b;
}

double minimum(double a, double b)
{
    if (a < b)
        return a;
    else
        return b;
}
```

Both of these functions perform the same trivial comparisons, and it seems redundant to define the functionality twice. We could do what we did before and use type aliasing to define these functions, but this would still require an explicit choice of `int` or `double` and wouldn't make the solution less complex.

Instead, we should use the `template` keyword.

```c++

template<typname T>
T minimum(T a, T b)
{
    if (a < b)
        return a;
    else
        return b;
}
```

The `template` keyword tells the compiler to create a new function with the given type at compilation. It will create a seperate function with integer parameters, double parameters, etc. based on what arguments get passed.

Note that the template requires all template item to be of the same type. So, in the above example, passing an `int` for the first argument and a `double` for the second will cause an error.

Templates consider almost no conversions. (will allow you to pass by reference, const, or constant reference).

We can try to get around this limitation of templates like this:

```c++
template<typename T, typename U>
?? mimimum(T a, U b)
{
    if (a < b)
        return a;
    else
        return b;
}
```

This won't work, since we have no way of knowing what to choose for the return value.

We just have to live with this for now.

---

Template Constraints:
  
  * The call has to match the template
  * the instantiated template must compile
  * the instantiated template must do what you want


---

Looking at another canditate for a template, we see a function to add the elements of the array.


```c++
template<typename T>
T sum(const T a[], int n)
{
    T total = 0;
    for (int k = 0; k < n; k++)
        total += a[k];
    return total;
}
```

This works fine for numeric types, but if we try to use it on, say, a string, we run into an issue, because a string cannot be initialized to 0.

To solve this, we have to introduce a new bit of syntax:

```c++
template<typename T>
T sum(const T a[], int n)
{
    T total = T();
    for (int k = 0; k < n; k++)
        total += a[k];
    return total;
}
```

Instead of initializing to 0, we use the default constructor syntax. When the template type is a builtin type, this returns 0. When it is another type, it will take the default constructor for that type.

So, for a double, it would equate to `double total = 0;`, for a string it would be `string total = "";`, and for a char pointer it would be `char* pointer = nullptr;`

---

<h4>Template Classes</h4>

Say we want to define a stack class to hold ints. This might be an implementation:

```c++
class StackOfInt
{
    public:
        StackOfInt();
        void push(int x);
        void pop();
        int top() const;
        int size() const;
    private:
        int m_data[100];
        int m_top;
};

StackOfInt::StackOfInt() : m_top(0)
{}

void StackOfInt::push(int x)
{
    m_data[m_top] = x;
    m_top++;
}

void StackOfInt::pop()
{
    m_top--;
}

int StackOfInt::top()
{
    return m_data[m_top - 1];
}

int StackOfInt::size()
{
    return m_top;
}
```

If we want to make this a stack that can hold any value, we can modify it as follows:

```c++
template<typename T>
class Stack
{
    public:
        Stack();
        void push(const T& x);
        void pop();
        int top() const;
        int size() const;
    private:
        int m_data[100];
        int m_top;
};


template<typename T>
Stack<T>::Stack() : m_top(0)
{}


template<typename T>
void Stack<T>::push(const T& x)
{
    m_data[m_top] = x;
    m_top++;
}


template<typename T>
void Stack<T>::pop()
{
    m_top--;
}

template<typename T>
int Stack<T>::top()
{
    return m_data[m_top - 1];
}

template<typename T>
int Stack<T>::size()
{
    return m_top;
}
```

In use, we instantiate a stack as follows:

```c++
int main()
{
    Stack<int> si;
    si.push(5);

    Stack<Coord> sc;
    sc.push(Coord(1, 2));

}
}
```

The problem with this implementation is that we include an array of discrete objects as a data member. For this reason, if there is no default constructor for the class, it may cause an error. You can choose to either make sure any stack items have default constructors or change the array to be an array of pointers or some other similar data structure.

---

<h4>STL</h4>

  * Developed by peeps at HP
  * Stands for "Standard Template Library"
  * relates to containers and algorithms that operate on containers
  * Examples we've seen:
      - Stack
      - Queue
  * New and useful types:
      - Vector

<h4>Vector</h4> 

```c++

#include <vector>

using namespace std;
int main()
{
    vector<int> vi;
    
    vi.push_back(10); // adds an element to the end of the array
    vi.push_back(20);
    vi.push_back(30);

    cout << vi.size() /* returns the number of elements */ << endl;
    cout << vi.front() /* returns the first element of the array,
                          in this case 10 */ << endl;
    cout << vi.back() /* returns the last elemnet of the array */ << endl;
    vi[1] = 40; // acts like a normal array. Can only change elements, not add
    //vi[3] = 40 would cause an error.

    vi.pop_back(); // removes the last element of the array

    // prints out the elements of the array in order
    for (size_t k = 0; k < vi.size(); k++)
        cout << vi[k] << endl;

    vi.at(1) = 60 // acts like vi[1] = 60
    // vi.at(3) = 70 would cause an error


    vector<double> vd(10); // initializes a double vector with size 10
                           // each element is initialized to 0.0

    vector<string> vs(10, "hello"); // initialize a string vector w size 10
                           // each element is initialized to "hello"
    int a[5] = {10, 20, 30, 40, 50};
    vector<int> vx(a, a+5); // creates a vec with the values in a 
                            // from a to a+5 into vx
}
```

In c++17, we could also use the following syntax to construct a vector:

```c++

vector<int> vx = {10, 20, 30, 40, 50}

```

 