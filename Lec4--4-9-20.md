<h1>Lecture 4</h1>

---

<h3>Agenda</h3>

  * Preliminaries
      - Dev Poll
      - Review your HW submissions before committing them to GradeScope
  * Recap
      - if ... then ..
      - Formalize definitions of &Sigma;<sup>+</sup> and &Sigma;<sup>*</sup>, as well as L<sup>+</sup> and L<sup>&amp;</sup>
      - Review formal Def. of DFA, formally definie Finite State Lnaguages
  * Examples of FSL's and Non-FSL's
  * Generalize DFA model to NFA model
  * Regular Expressions
  * Models as reps of patterns and basic principles
  * Classes of languages and closure properties

---

<h3>Example</h3>

  * To represent the vocab (ie, meaningful symbols, punctuation, keywords, and a symbol for "blank") or most programming languages, greatly simplified, we could use an alphabet, &Sigma;:

Let &Sigma; = {"<strike>b</strike>", a, b, c, ..., z, 0, 1, ..., 9, +, `<`, "=", if,  then, ";"}

Ignoring keywords:

if<strike>b</strike>counter`<`max<strike>b</strike>then<strike>b</strike>counter=counter+1;  | | = 34 symbols

recognizing keywords:

<u>if</u><strike>b</strike>counter`<`max<strike>b</strike><u>then</u><strike>b</strike>counter=counter+1;  | | = 38 symbols

  * In a compiler context, the front-end is usually:
  * tokenizer/lexical scanner (like 1st interpretation)
      - interpret in something more like the second interpretation
      - distils this down into things called `tokens` 
  * This would produce 11 "tokens"
      - if counter < max then counter = counter + 1 ;

---

<h3>Kleene<sup>+</sup> and Kleene<sup>*</sup></h3>

  * &Sigma;<sup>+</sup> and &Sigma;<sub>*</sub> are called the Kleene<sup>+</sup> and Kleene<sup>&amp;</sup>
      - &Sigma;<sup>+</sup> = {w | w is a sequence of *one* or more symbols over &Sigma;}
      - &Sigma;<sup>&amp;</sup> = {w | w is a sequence of *zero* or more symbols over &Sigma;} = &Sigma;<sup>+</sup> &cup; {&epsilon;}

  * We can formally extend these defs from an alphabet to a language, L
  * The easiest way is to first define *finite* iterative concatenation on a language "L<sup>i</sup>"
      - With set notation:
          + L<sup>0</sup> = {&epsilon;}
          + For i &ge; 1, L<sup>i</sup> = {w<sub>1</sub>w<sub>2</sub>&sdot;&sdot;&sdot;w<sub>i</sub> | for all 1 &le; j &le; i, w<sub>j</sub> &isin; L}
      - Or recursively:
          +  + L<sup>0</sup> = {&epsilon;}
          + For i &ge; 1, L<sup>i</sup> = L &sdot; L<sup>i-1</sup>


---

<h3>Formal def of DFA</h3>

  * The transition **function** &delta;:Q x &Sigma; &rarr; Q
      - single-valued, only one possible "move" per "step"
  * Correctness of DFA:
      - if Input w &isin; L(M)  then M must accept w
          + L(M) is the language that the machine M is supposed to accept
      - If Input w &notin; L(m) then M must reject or block
      - Accepting and rejecting is *only* meaningful if it gets to the end of the string.
  * Another interpretation: "choosy Generator"
      - the machine doesn't "read" symbols, it writes symbols
      - not every input results in a state that will write, only the ones that end in an accepting state.

---

<h3>Example 1</h3>

  * Let &Sigma; = { a, b }
  * Let w &isin; &Sigma;<sup>*</sup>
  * Define for this example L(w) &equiv; {xw | x &isin; &Sigma;<sup>*</sup>}
      - This is the set of all strings over &Sigma; that end in w. (including just w)
  * Given a particular w, L(w) is a well-defined language
      - w = aa
      - L(w) = {aa, aaa, baa, aaaa, abaa, baaa, bbaa, ...}
  * DFA for w = aaabbb, L(w) = L(aaabbb)
  * __F4.1__
      - Has 7 states, and has exactly 14 transitions/edges
          + for every fully specified DFA, 
              * number of edges |E| = size of alphabet |&Sigma;| * number of states |Q|
              * (|x| is cardinality of set x)
          + The length of w |w| = 6, and in general for a machine built along these lines, we need one more state than the length of w
      - Generally, going from (a, i) --(a)--> (a, i+1)
          + &delta;((a, i), a) = (a, i+1)
      - (b, i) --(b)--> (b, i+1)
          + &delta;((b, i), b) = (b, i+1)
  * Something to think about: strings of the form 12 + 13 = 25 (recognizing strings where the math works out)

----

<h3>Example 2</h3>

  * &Sigma; = {a, b}
  * {ww | w &isin; &Sigma;<sup>*</sup>}
      - Strings of "even length" that are repeated
          + Prolly can't be recognized by a DFA
  * {ww<sup>R</sup> | w &isin; &Sigma;<sup>*</sup>}
      - Same story here, too complex prolly
  * {w#w<sup>R</sup> | w &isin; &Sigma;<sup>*</sup>}
      - &Sigma; = {a, b, #} = L
  * All of these are non Finite State Languages (Non-FSL's)
  * __F4.2__
      - There is no bound on the size of w, but there is a finite bound on the size of the DFA
          + So, by the time the DFA encounters #, there are 2<sup>w</sup> possible input strings
          + Say we have w' &ne; w, also in L
          + &delta;<sup>*</sup>(q<sub>0</sub>, w#) = &delta;<sup>&amp;</sup>(q<sub>0</sub>, w'#)
              * since at any state, starting at that state and receiving the same input must result in the same output, these two must share the output state
              * By pigeonhole principle, since there are a finite number of states and an infinite number of possible inputs, such a w and w' must exist
                  - w#w'<sup>R</sup> accepted by M
                  - w'#w<sup>R</sup> accepted by M

---

<h3>Non-deterministic Computation</h3>

  * What if multiple computations could be done on the same input?
      - ie, choice is made
      - in other words, more than one branch for the same input on a state
  * If any computation accepts, then the machine accepts
  * If ALL the computations fail to accept, then the machine rejects
  * Formal definition of Non-deterministic Automaton
  * Q, &Sigma;, q<sub>0</sub>, and F same as for a DFA, ands
      - Let &Sigma;<sub>&epsilon;</sub> = &Sigma; &cup; {&epsilon;}
      - __F4.3__ (L(aaabbb))
      - DFA: input in L &rarr; accept
          + input not in L &rarr; Reject/block
      - NFA: input in L &rarr; There must be at least one accepting computation
          + input not in L &rarr; There are NO accepting computations
          + for input xaaabbb, x &isin; &Sigma;<sup>*</sup>, there exists some computation for which this accepts.
          + The only way to get to an accepting state is to pass through the sequence aaabbb which we are looking for. Otherwise, the NFA stops and blocks.
  * Tree interpretation of NFA
      - Once you've gone through every possible computation in a tree, if you go through all the leaves of the tree, then if any one of them is an accepting state, the whole tree is accepting.
  * Where the DFA is a "choosy generator", the NFA is a slightly less "choosy" generator.
  * Guess and check interpretation: whenever the machine has a choice, it "guesses" which choice is the right answer, and verifies that the guess ends in an accepting state  

---

<h3>Big picture</h3>

  * NFA is simply a convenient intermediate representation bt DFA and practical thing (ie tokenizer, parser, etc)
      - DFA: machine running an imperative programming language
      - Practical thing: machine program
  * All of these are representations of a pattern 
      - representation of how to recognize the patterns in the input
  * Spoiler: given an NFA, you can transform it into a DFA using an algorithm