<h1>Lecture 5</h1>

---


<h5>Common uses of Grammars</h5>

  * Natural Languages
  * Programming Languages
  * Data formats
  * grammars themselves
  * Difficult to represent with a grammar:
      - syntax graphs

<h5>Syntax graphs</h5>

  * use: large grammars fr ess-common languages
      - eg, SQL variant for DB2

```Scheme
Example: grammar as text

Nonterminals are surrounded by angle brackets <>
<cond> -> ( cond <cond clause>+ )
        | ( cond <cond clause>* (else sequence))

```

This representation has a lot of repetition; it can probably be represented more concisely with a drawing

<img src="https://media.discordapp.net/attachments/581226308672159747/633414720971603968/20191014_142338.jpg?width=719&height=405" 
style="width: 80%; margin-right: auto; margin-left: auto; display: block;" />

>This is not a finite state machine; it is a FSM + Stack, or a pushdown automata

---

<h5>Parsers</h5>

  * How do we convert the above diagram into a parser?

```c
    bool parse_cond(void) {
        if (gettok() != '(')
            return false;
        if (gettok() != COND)
            return false;
        if (parse_cond_clause()) {
            while (parse_cond_clause())
                continue;
            if (gettok() != ')')
                return false;
        } else
            return true;
    }
```

<h5>Problems with parsers</h5>

1. Recursion
    + when a rule has itself in its RHS
    + need a stack to parse; can't do purely recursively
2. Alternation
    + differing paths (OR decisions) -- which is the right way to go?
3. Concatenation
 
---

<h5>Homework 2</h5>

  * Hints:
      - fragments = token list
      - acceptor = fragment -> fragment option
          + reminder:  

```ocaml
    (* Discriminant Union *)
    type 'a option = 
        | None
        | Some of 'a
```

  * cont...
      - matcher = acceptor -> fragment -> fragment option
      - OR, matcher = acceptor -> acceptor

```ocaml
    (* Recursion *)
    (* Matcher function *)
    A-> fun acceptor ->
            fun frag ->
                acceptor frag

    (* Can be simplified as follows: *)

    A->  fun acceptor -> acceptor

    (* ------------------------- *)

    (* Alternation, with 2 alternatives *)
    (* Another functional representation, with checking *)
    B-> t
        fun acceptor ->
            fun frag ->
                match frag with 
                    | (T"t") S -> acceptor S  (* S is the suffix *)
                    | _ -> None

    (* For some arbitrary non-terminal C *)
    C -> D
    C -> E

    let mX = fun accept -> fun frag -> let r = mD accept frag 
                                                    in match r with 
                                                        | Some x -> Some x
                                                        | None -> mE accept frag

    (* ------------------------- *)

    (* Concatenation, for 2 things G and H *)
    (* A new grammar example:   *)

    (*    F -> GH               *)
                      (*aG acceptor for g*) (* sG suffix for G *)
        let mF = fun accept -> let aG = fun sG -> 
                                            mH accept s (* mH accptor for H *)
                               in 
                               mG aG frag

        (* This can be significantly simplified, to the following: *)

        let mF = fun accept -> mG (mH accept)

        (* In this case, accept is the acceptor function for H. mH accept  *)
        (* returns the acceptor function for G, and mG takes this acceptor *)
        (* and returns the acceptor function for G. *)


        (* Note on some of the simplification:         *)
        fun x -> f x    
        (* is the same as *)
        f
        (* bc it returns a function that takes x and returns f x, the same *)
        (* as f.  *)

        (* However, this relies on the fact that the return value of this  *)
        (* function is a function on the input parameter; for example,     *)
        let mF = fun accept -> mG (mH accept) 
        (* cannot be simplified to *)
        let mF = mG (mH)
```

---

```ocaml
(* Concatenation, generalized to N things *)
(* a function pattern list -> matcher *)
(* accepts a list of patterns and returns a matcher *)
let rec mmfcpl = function 
    | [] -> id (* identity function *)
    | p::ps -> 
        let mp = make_matcher p
        and mps = mmfcpl ps
        in fun accept -> mp (mps accept)

```

```ocaml
    (* Alternation, generalized to N things *)

    (* function to take 2 inputs and return None *)
    let match_never _ _ = None

    let mmds = function
        | [] -> match_never
        | p::ps ->
            let mp = make_matcher p
            and mps = mmds
            in fun accept -> fun frag -> match mp accept frag with
                | None -> mps accept frag
                | x -> x

```

---

<h5>Patterns</h5>

```ocaml
match E with
    | P1 -> E1
    | P2 -> E2
    | Pn -> En

```

| Some Patterns | = | - |
| --- | --- | --- |
| `0`, `1`, `[]` | constants | simple, matches only that value |
| `x` | `id` | always matches, binds identity to value |
| `P1,P2` | -- | (`P1` matches first, `P2` matches second) |
| `P1:P2` | lists | `P1` matches `head`, `P2` matches `tail` |
| `[[P1; P2; (P3,P4)]` |  |  |

