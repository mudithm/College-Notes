<h1>Lab 3</h1>

_Dis1A, Slides are_ [here](https://piazza.com/ucla/fall2019/cs131/resources)

---

<h5>Currying</h5>

   * OCaml replaces functions with multiple arguments with a series of lambda functions that each take one argument

<h5>Partial Application</h5> 

  * Calling a function with only some of the args returns a function that takes the remaining arguments

Functions

```OCaml
let f a b = a b;;

(* returns a function a that accepts argument b *)
('a -> 'b)->'a->'b
```

Option Type

```OCaml
let divide a b = match b with
    | 0.0 -> None
    | _ -> Some (a /. b)
;;
```

>None and Some are both variants of the Option type

---

<h4>Homework 2</h4>

Def peep the slides for this part

<h5>Problem 1 -- Warm-Up</h5>

  * write a function to convert old syn to new syn

<h5>Problem 2 -- Warm-Up</h5>

  * write a function parse_tree_leaves that returns a leaves in the tree from left to right 

<h5>Problem 3</h5>

  * write a function make-matcher gram that returns a matcher for the grammar gram
  * matcher tries to find some prefix that can be drived using a given grammar
  * EX: find a match for the sentence "1 + 0 + 1" using the grammar below
  * acceptor is a function that teslls us whether the remaining suffix is acceptable

Grammar:
| Nonterminal |->| Rule |
|---|---|---|
| `Expr` |->| `Num Binop Num` |
| `Expr` |->| `Num Binop Expr` |
| `Binop` |->| `+` |
| `Binop` |->| `-` |
| `Num` |->| `0` | 
| `Num` |->| `1` |

Matching "1 + 0 + 1"
| Sentence | Rule |
| --- | --- |
| `Expr` | `Expr -> Num Binop Num` |
| `Num Binop Num` | `Num -> 0` |
| `0 Binop Num` | `0` doesn't match, backtrack to `Num -> 1` |
| `1 Binpop Num` | Binop -> + |
| `1 + Num` | Num -> 0 | 
| `1 + 0` | Found matching prefix `["1"; "+"; "0"]`, remaining suffix `["+"; "1"]`|
|       |  Call acceptor with suffix `["+";"1"]` |
|       | if accepted, return acceptor's return value |
|       | if rejected, backtrack to previous step and try other alternatives |


---

<h5>Problem 4</h5>

   * Write a function make_parser gram that takes same, but returns a parse tree

<h5>Probs 5-7 </h5>

  * Write a non-trivial test-case for make-matcher
    - write your own grammar
  * write test case for make-parser
  * write a report
    - explain when your parser would fail
  
---
  
<h5>Old Homework as a starting point</h5>

  * Patterns
    - Frag matches list of symbs
    - Junk k matches up to k symbs
    - Or matches any pattern in the list
    - list matches a concatenation of patterns
    - closure matches a pattern 0 or more times
  * Make Matcher
    - takes a fragment and an acceptor


```OCaml
match_nt A [A;G;T]
  (fun suffix -> match_nt G suffix
      (fun suffix2 -> match_nt G suffix2
                accept_empty))

let append_matchers matcher1 matcher2 frag accept = 
  matcher1 frag (fun frag1 -> matcher2 frag1 accept)

let make_appended_matchers make_a_matcher ls = 
  let rec mams = function
    | [] -> match_empty
    | head :: tail -> append_matchers (make_a_matcher head) (mams tail)
  in mams ls
```

Rly read through the slides before you do the homework -- it seems like they will help quite a bit