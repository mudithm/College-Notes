<h1>Lecture 2</h1>

---

<h4>Booting on an operating system</h4>

  * __UEFI:__ Unified Extensible Firmware Interface
  * Firmware is software that remains in your hardware, usually on EEPROM
  * When you power your computer on, the instruction pointer is in the ROM.
  * The firmware will then copy you operating system to RAM and the computer boots
      - With Linux, it will first load GRUB or another bootloader and then the OS
  * __GUID:__ Globally Unique Identifier, a 128 bit number that delineates different partitions
  * __GPT:__ GUID Partition table, part of the UEFI that lists the GUID and basic information on the disks. Location specified by the UEFI standard
  * CMOS is built onto the motherboard, contains a small amount of data 
  * Example:

![Image of Boot Sequence](https://www.kerneldebuggers.com/wp-content/uploads/2017/06/Boot-Process.jpg)

---

<h4>BIOS</h4>

  * Originally, meant Basic Input Output System
  * Its intent was to be preloaded firmware that you could run whenever you wanted
  * From the CPU's POV, it looks like RAM
  * Contains subroutines that are not necessarily high-speed, etc.
  * Professor's Computer:
      - read_ide_sector(int s, char *a ) // only good for the first TB
          + picks some data from disk and puts it into RAM. 512 Bytes
          + parameters are sector number and address
          + Uses PIO, programmed I/O (CPU uses special instructions to interact with bus and registers)
          + Special instructions:   
              * inb( bus address )
                  - takes the address of something in the bus and moves it into a register
                  - Associated with the inb subroutine in C, written in machine code
                  - returns the byte read from the bus register
              * outb( bus address, value )
                  - places the specified value into a bus register
                  - associated with the outb subroutine in C, written in machine code
              * insl ( bus address, buffer, number of words )
                  - takes large amounts of data from the register.

Code:
```c
// Read a sector from an IDE drive. s is the sector number, a the address
// to be read to
void read_ide_sector(int s, char *a)
{
    // wait for the disk to be ready.
    // 0x1f7 is the address of the status register, as
    // specified by the manual. 0x40 indicates that the
    // status is no longer busy
    while(inb(0x1f7) & 0x60 != 0x40)
        continue;

// Copy the sector number into registers, one byte at a time.
// This is for communicating with the disk controller
/* 
    outb(0x1f2, 1); // sector count
    outb(0x1f3, s & 0xff); // the & 0xff is unneccessary since the outb
                           // function automatically takes only the lowest
                           // order byte.
    outb(0x1f4, s >> 8 & 0xff);
    outb(0x1f5, s >> 16 & 0xff);
    outb(0x1f6, s >> 24 & 0xff);
*/
    outb(0x1f2, 1); // sector count (number of sectors to read)
    // gives sector number to the disk controller
    for (int i = 0; i < 4; i++)
        outb(0x1f2 + i, s >> (8 * i));

    // Sets the status register to busy, with the command or reading disks
    outb(0x1f7, 0x20);
    
    // wait until the controller is done reading
    while(inb(0x1f7) & 0x60 != 0x40)
        continue;

    // reads 128 words and places the data into a
    insl(0x1f0, a, 128);

}

```

---

<h4>Booting, cont</h4>

  * The BIOS will also do some self-testing
  * then it will probe the bus
  * It will continue to read sectors from the until it identifies a sector that is bootable (Last 2 bytes match a specific pattern)
  * It will then set the instruction pointer to this location, and the disk drive will then essentially have control of your computer.
  * Such a program would have to be very small, so that it could be placed  into memory by only one sector

Code:

```c
#include <ctype.h>

unsigned long int words = 0;
bool in_word = false;
int s = 1; // sector 1 (sector 0 contains the code)

// Loop through the sectors on the drive until the file is finished
for (int s = 1;;s++))
{
    // read one sector into a temporary array
    char buf[512];
    read_ide_sector(s, buf);

    //count the number of words in the sector
    for (int j = 0; j < 512; j++)
    {
        // if the character is 0, the file is over
        if (buf[j] == 0)
            report_words(words);
        bool is_alpha = isalpha(buf[j]) != 0;
        words += is_alpha & ~in_word;
        in_word = is_alpha;
    }
}

// prints the txt to the screen
void report_words(unsigned long n)
{
    // set a pointer for the memory location used to access the screen
    char *screen = (char*)0xb8000;

    // get a point that is approximately in the center of the screen
    char *p = screen + (80 * 25) - 80

    // print each integer in the result, in reverse order.
    // We use a do-while loop because we want n to display even if it is 0.
    do 
    {
        // assign the memory to the character value of the digit,
        // using memory-map io
        *--p = n %10 + '0';
        *--p = 7; // gray on black
        //divide n by 10
        n /= 10
    } while (n)

    // Make sure that the number stays on the screen
    while(true)
        continue;
}
```

Because we want the first instruction to execute immediately and not be contained withing a main function, we have to use specific gcc flags or edit the assembly code manually.

Standalone programs, that don't need operating systems, are very popular in the embedded systems world.