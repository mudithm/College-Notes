<h1>Lab 2</h1>

Slides found [here](https://piazza.com/ucla/fall2019/cs131/resources)

---

<h5>OCaml functions</h5>

  * `let sum a b = a + b` 
      - `sum (a b)` would try to call function `a` with argument `b`, since OCaml uses functional notation
      - `sum a,b` would treat `a,b` as a tuple
      - We only use parentheses to change the order of an operation
  * Lambda functions (anonymous functions)
      - regular functions that do not have a name

```OCaml
`let add_one a = a + 1` 
`val add_one : int -> int = <fun>`
```

<h5>Functions with multiple arguments</h5>

  * Each function in OCaml actually only takes one argument
      - functions with multiple argument are replaced with internal lambda functions that take only one argument

```OCaml
let sum a b = a + b;;
(* becomes *)

let sum (fun a -> (fun b -> a + b));;
val sum: int->int->int = <fun>
(* each arrow represents an arrow in a nested lambda function *)

(* the below is a partial argument *)
(* it returns a new function with the first argmuent already set *)
let add_one = sum 1;;
val add_one : int -> int = <fun>
```

<h5>Function Types</h5>

  * OCaml tries to figure out both input and output types automatically
  * Sometimes, there's nothing to indicate the type:

```OCaml
# let rec my_map func my_list = match my_list with
    | [] -> []
    | head::tail -> (func head) :: (my_map func tail);;
    (* Recursively calls the function on the head & tail of the list *)

val my_map : ('a -> 'b) -> 'a list -> 'b list = <fun>
(* 'a and 'b tell us that the arguments are polymorphic' *)
(* all intances fo 'a must match with each other. Same for 'b *)
```

  * after partial application, our types become fixed

```OCaml

val my_map:('a -> 'b) -> 'a list -> 'b list = <fun>

(* partial assignment that assigns the function of my_map to add 1*)
# my_map (fun x -> x + 1);;
-: int list -> int list = <fun>

(* partial assignment that assigns the function of my_map to add 1 flt*)
# my_map (fun x -> x +. 1,0);;
-: float list -> float list = <fun>

```

<h5>Recursive functions</h5>

  * must include the `rec` keyword in the function declaration
  * Mutual recursion 

```OCaml
(* Mutual recursion requires the and keyword *)
let rec is_even x = match x with 
    | 0 -> true
    | x -> is_odd (x - 1)

and is_odd x = match x with
    | 0 -> false
    | x -> is_even (x - 1);;


# is_even 10;;
-:bool = true

# is_odd 10;;
-:bool = false

#is_odd 9;;
-:bool=true
```
>Since both of these functions rely on each other, they must be defined at the same time. However, each can be called independently

---


<h5>Infix functions</h5>

  * Sometimes, defining your own infix operators might make your code simpler. Look this up in the slides lol
  * Warning: function definitions always override existing definitions: no overloading
      - i.e., if you change the types the function accepts, it will not accept the original
  * You can also do the reverse, using an infix operator as a regular function
  * `(+) 1 2`, etc

---

<h5>Pattern Matching</h5>

```OCaml
# let first x = match x with
    | (left,_)->left;;

    (* returns first element of tuple *)

(* '= function' is equivalent to 'x = match x with' *)
# let first = function
    | (left,_) -> left;;

    (* this function implicitly takes an argument and does *)
    (* pattern matching *)

# let first (left,_) = left;;
    (* You can also do pattern matching in the function args,*)
    (*but it is limited in that it cannot match multiple things *)
```

---

<h5>Function Type Exercises **Prolly on the test</h5>

  * do these, from the slides

---

<h5>Look at type recap from the week 1 slides</h5>

  * Built-in types
      - int, float, char, string, bool, unit, tuple, list, function
  * variant types
      - our useful type can be constructed using mult different types
      - useful eg when you need mult types in one list
```OCaml
type ('nonterminal, 'terminal) symbol = 
    | N of 'nonterminal
    | T of 'terminal;;

type awksub_nonterminals = Expr | Lvalue | Incrop | Binop | Num;;

(* List containing 3 elements: 1 'T' (terminal), *)
(* 1 'N' (nonterminal of type awksub of type Expr), *)
(* 1 'T' (terminal) *)

#[T"("; N Expr; T")"]
-:(awksub_nonterminals, string) symbol list = [T"("; N Expr; T")"]
```

----

<h5>Option Type</h5>

  * sometimes your function cannot come up for a return value
      - eg Div by 0
  * In these cases we coild return some special result (-1, empty list, inf, etc)
  * We could also throw an exception
  * Problem: easy to forget to check
  * Another is to return an option type

```OCaml
let divide a b = match a,b with
    | x,y when y = 0.0 -> None
    | x,y -> Some(x /. y);;

(* Option is defined as a match with one tag "None" and *)
(* the other as "Some" of 'a *)

# divide 1.0 0.0;;
-:float option = None (* type is option *)

# divide 1.0 2.0;;
-:float option = Some 0.5
```
>Downside: we have to handle this in the calling function

```OCaml
let print_division a b = match (divide a b) with
    | Some x -> print_float x
    | None -> print_string "Undefined";;

# print 1.0 0.0
"Undefined"

# print 1.0 2.0
0.5

(* Note: since we are printing in these functions, the expected *)
(* return type will be "unit" *)
(* float->float->unit *)
```

---

<h5>Recursive Types</h5>

  * We can use types to define recursive data structurs, such as trees

```OCaml
# type tree = 
    | Leaf of int
    | Node of tree * tree;;

# let my_tree = Node (Node (Leaf 1, Leaf 2), Node (Leaf 3, Leaf 4))

(* find left-most leaf in the tree *)
# let rec first_leaf = function
    | Leaf x -> x
    | Node (left, right) -> first_leaf left;;

# first_leaf my_tree;;
-: int = 1

```

---

<h5>List model recap -- look at the slides</h5>

  * `map` 
  * `filter` 
  * `rev` 
  * `for_all` 
  * `exists` 
  * `fold_left` 
      - summarize a list to one value
      - also called `reduce` in other languages

```OCaml
(* the lambda function in the parentheses takes an accumulator and *)
(* an input, and returns the sum. We initialize the acc to 0 *)

# let sum my_list = List.fold_left(fun acc x -> acc + x) 0 my_list;;
# sum [1, 2, 3];;
-:int = 6

(* ^ concatenates strings *)
# let concat my_list = List.fold_left(fun acc str -> acc ^ str) "" my_list;;
# concat ["a";"b";"c"]
-: string = "abc"
(* @ concatenates lists *)
# let flatten my_list = List.fold_left(fun acc l -> acc @ l) [] my_list;;
# flatten [["a"];["b"];["c"]]
-: list = ["a", "b", "c"]

```

<h5>Split and combine</h5>

  * `split` splits a list of tuples into a list of lists corresponding to each element index
  * `combine` does the reverse
  * Check out the slides for examples

```OCaml
[("Bilbo", 129);
    ("Frodo", 51);
    ("Merry", 37);
("Pippin", 29)];;

(* function to get the sum of hobbit ages *)
let sum hobbits = List.fold_left(fun acc x -> acc + (snd x)) 0 hobbits;;

```

<h5>Homework 2</h5>

  * Deadline Monday 10/21
  * Significantly harder than the first homework!
  * Main task: how to derive a given sentence given a grammar
  * Grammar:
      - defines a language
          + What strings are valid sentences
      - Consists of 
          + Rules
          + Non-terminal symbols
          + Terminal symbols
      - Rules are applied by replacing non-terminal symbols with the right-hand side of the rule
  * Ex: 
      - `PHRASE -> NOUN VERB` 
      - `NOUN -> mary` 
      - `NOUN -> mark` 
      - `VERB -> eats` 
      - `VERB -> drinks` 
  * Grammars usually det whether a string is valid, and what its structure is
  * Most common way is _top-down derivation_ 
      - Start from the start symbol, keep trying diff rules in order
      - try rules in order by replacing the left-most non-terminal symbol
  * Ex: `mark drinks` 

| Current Sentence | Rule | 
|---|---|
|`PHRASE`|`PHRASE->NOUN VERB`|
|`NOUN VERB`|`NOUN->mary`|
|`mary VERB`|Backtrack|
|`NOUN VERB`|`NOUN->mark`|
|`mark VERB`|`VERB->eats`|
|`mark eats`|Backtrack|
|`mark VERB`|`VERB->drinks`|
|`mark drinks`|Done!| 

<h5>Derivation Tree/Parse Tree</h5>

  * The derivation we found is: 
      - `PHRASE -> NOUN VERB`
      - `NOUN -> mark` 
      - `VERB -> drinks` 

---

<h5>Homework 2: Problem 1 (Warm-Up)</h5>

  * Our syntax for grammars is slightly different from last week; write a function to convert old syntax to new syntax
  * look at slides
  * Tree is rep'd using a data structure

<h5>Homework 3: Problems 3-7</h5>

  * Writing a parser/matcher for context-free grammar
      - we'll discuss this more next week
  * Old hw solution is provided as a hint