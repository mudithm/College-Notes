<h1>Lab 1</h1>

_Slides link:_  [here](http://piazza.com/redirect/s3?bucket=uploads&prefix=attach%2Fk111z7l37yqid%2Fisia64xz73v19g%2Fk11v5s72aa4q%2FCS131__ocaml_1.pdf)

---

<h4>Homework</h4>

  * Work on the homework yourself
  * Mostly graded using automated scripts
      - No compiling, no credit
      - code must behave exactly as the specs say
      - function signature must match your function signature, otherwise will get no credit
  * Correctness is more important than performance, but you might lose pts if it takes _too_ long to execute
  * Homework will be submitted to CCLE
  * 6 HW assignments + a final project
  * Second homework will take significantly more time than the first homework

<h4>Grading</h4>

Type | Grade
---|---
Homework | 32%
Midterm | 24%
Final | 44%


----

<h4>ocaml</h4>

<h5>What is Functional Programming</h5>
  * No Side Effects
      - Pure functions: will always return the same value assuming the same inputs 
      - variable's values never change
      - If you call a function twice with the same arguments, the output should be the same (like mathematical functions)

<h5>Why are we learning this?</h5>

  * Similar ideas can be found in most programming languages
      - EG python, C++, Swift, Kotlin, etc
  * Functional programming makes debugging and testing easy
  * Easy to build scalable systems

<h5>ocaml Introduction</h5>
  * Functional Programming Language
  * Statically Typed
      - Every variable has a type, functions define that the types of input parameters should be
      - Compiler/interpreter can warn about many programming mistakes early
      - makes it faster to execute, as there is less need for safety checks
  * Garbage collecting languages

<h5>Installing ocaml</h5>

  * Install on local machine
  * Or on SEASNet servers 6, 7, 9, 19
      - Make sure version is correct
      - `ocaml --version` should be `4.09.0` 
  * Alternative Toplevel for ocaml: `utop` 
      - Not necessary, but makes coding a bit easier


<h4>Hello, World!</h4>

```ocaml
# print_string "Hello, World!";;
Hello World!
- : unit = ()
```

  * First part `print_string` is the function called, next is argument (`Hello, World!` 
  * Statement ends with two semi colons
  * Variables
      - Not really variables, value cannot be changed
  * statement before the `:` in the last line represents where the value we computed is being stored -- in this case, since we aren't storing anything, it is a dash. 

```ocaml
# let my_value = 5;;
val my_value : int 5
```

---

  * Lists:
      - `let numbers = [1; 2; 3; 4; 5]` 
      - All elements will have the same type
      - Under the hood, they are immutable singly-linked lists
          + ie, iterating is fast, random access is slow
      - List Operations
          + consists of head and tail
              * accessing: `List.hd`, `List.tl` 
          + Adding a new element to the beginning of a list is easy
              * `0 :: [ 1; 2; 3]` gives us a new list `[0; 1; 2; 3]` 
              * `0 :: 1 :: 2 :: [3]` gives `[0; 1; 2; 3]` 
                  - Note that `::` is right associative, meaning that the prev statement becomes `0 :: (1:: (2:: [3]))` 
          + Note: lists are immutable
              * new list is created with each operation

---

<h5>Functions</h5>

```ocaml
# let average a b =
    (a + b) / 2;;
val average : int -> int -> int = <fun>
```

  * `let` binds a function with parameters `a` and `b` to the name `average` 
  * Note that inputs and outputs are inferred to be integers
  * Assigning a value and defining a function use the same syntax
      - variables can be thought of as functions that return a constant value
  * Calling a function, if my_average defined as float
```ocaml
# let average a b =
    (a +. b) / 2.0;;
val average : float -> float -> float = <fun>

# let my_average = average 3 5;;
Error: this expression has type int...
```

<h5>Recursive functions</h5>

```ocaml
# let rec factorial a =
    if a = 1 then 1 else a * factorial (a-1);;
val factorial : int -> int = <fun>

...

# factorial 5;;
- : int = 120
```

<h5>Local Variables</h5>

```ocaml
# let average a b =
    let sum = a +. b in
    ...
```

  * the `in` keyword indicates that it is a local variable

<h5>Lambda Function</h5> 

  * Lambda/Anonymous functions are not bound to any name
  * useful when using a function as a function argument
      - very common in funct prog
      - "higher order function"

```ocaml
# (fun x -> x*x)
```

---

<h5>Useful list operations</h5>

  * `Map` transforms a list by applying a function on each element

```ocaml
# List.map (fun x -> x*x) [1; 2; 3; 4; 5];;
- : int list = [1; 4; 9; 16; 25]
```

  * `Filter` returns a list containing elements that match a give condition

```ocaml
# List.filter (fun x -> x < 3) [1; 2; 3; 4; 5];;
- : int list = [1; 2]
```

  * `for_all` returns true if a cond applies for every elements in the list

```ocaml
# List.for_all (fun x -> x < 3) [1; 2; 3; 4; 5];;
- : bool = false
# List.for_all (fun x -> x < 6) [1; 2; 3; 4; 5];;
- : bool = true
```

  * `exists` checks if any element matches a certain condition

---

<h4>Problems</h4>

```ocaml
(* increment all in list *)
# List.map (fun x -> x + 1) [1; 2; 3; 4; 5];;
- : int list = [2; 3; 4; 5; 6]
```

```ocaml
(* get even elements of list *)
# List.filter (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8];;
- : int list = [2; 4; 6; 8]
```

```ocaml
(* see if all are even *)
# List.for_all (fun x -> x mod 2 = 0) [1; 2; 3; 4; 5; 6; 7; 8];;
- : bool = false
# List.for_all (fun x -> x mod 2 = 0) [2; 4; 6; 8];;
- : bool = true
```

---

<h4>Pattern Matching</h4>

  * More powerful version of the switch statement in other languages
  * Allows you to list all the different cases in a clean way
      - underscore `_` matches any value that does not match the earlier rules
      - cleaner than conditionals when there is a large number of possible cases

```ocaml
# let is_zero x =
    if x = 0 then true else false;;
```

```ocaml
# let is_zero x = match x with 
    0 -> true
  | _ -> false;;
```

```ocaml
(* can also include conditions using the when statement *)
# let rec factorial a = match a with
    x when x < 2 -> 1
  | x -> x * factorial (x - 1);;
```

```ocaml
(* Dealing with tuples *)
# let tuple_matcher x = match x with
    | (1, a) -> a  (* pipe on first statement is optional *)
    | _ -> 0;;

...

tuple_matcher (1, 5);;
-:int=5

tuple_matcher (0, 5);;
-:int=0
```

---

<h4>Data types</h4>

  * Native data types
      - `int`
      - `float`
      - `char`
      - `string`
      - `bool`
      - `unit`
          + means no value
      - `list` 
          + elements have same type
          + immutable
      - `tuple` 
          + can combine different data types
          + accessing elements: `fst my_tuple`, `snd my_typle` 
              * pattern matching for other elements
      - `functions` 
  * Defined Data Types

```ocaml
(* Wrapping existing types *)
type age = int;;
type name = string;;
type person = age * name;; (* star means tuple of this type *)

let print_name (p : person) = match p with 
    | (p_age, p_name) -> print_string p_name;;

let my_person = (111,"Bilbo":person);;
Bilbo
```

```ocaml
(* Variant data types -- used when there are*)
(* multiple subtypes of one data type *)

type ccle_user = 
    Student of string
    | TA of string
    | Professor of string ;;
let user = Professor "Eggert";;

...
val user : ccle_user = Professor "Eggert"
...

type my_type = 
    | A of string
    | B of int ;;

let my_print x = match x with
    | A a -> print_string a
    | B b -> print_int b;;

...
my_print (A "some string");;
some string

my_print (B 5);;
5
```

---

<h4>Context-Free Grammars</h4>

  * Grammar defines a language
      - What strings a re valid in a language
  * E.G. We could define a grammar for our own programming language to define what kind of syntax is allowed
      - Grammar does not say what the instructions in that language mean, just what syntax is allowed
      - eg check that print(":"hello world") is valid without knowing what it does
  * Ex grammar:
      - PHRASE -> NOUN VERB
      - NOUN -> mary
      - NOUN -> mark
      - VERB -> eats
      - VERB -> drinks
  * Grammar consists of rules (eg NOUN->mary), non-terminal symbols (eg NOUN), and terminal symbols (eg mary)
  * Grammar has a starting point, in this case PHRASE
  * Rules tell us how non-terminal symbols can be replaced
  * possible strings: mary eats; mary drinks; mark eats; mark drinks
  
<h5>Consider a slightly modified grammar</h5>

  * Ex grammar:
      - PHRASE -> NOUN VERB
      - NOUN -> mary
      - NOUN -> mark
      - VERB -> eats
      - VERB -> drinks
      - ADJECTIVE -> red 
  * ADJECTIVE cannot be used by any rules, so it is pointless

---

<h5>Homework 1</h5>

  * Allowed Modules
      - Pervasives module provides core functionality of ocaml
          + no deed to explicityly import this
      - Lists module
  * Problems:
      1. Write a function to det if one list sis a subset of another
      2. write a function to determine if two sets are wual
          + both shoul contain the same elements
      3. write a function that returns the union of two stes
      4. function that returns the intersection of two sets
      5. funciton that returns the difference of two sets
      6. Write a function thta returns the computed fixed point of a given function 
        + value x where f(x) = x
      7. Write a funct hta takes a grammar as its input and returns a grammar where all unreachable rules have been removed
      8. write at least one test case for each of the problems
  * Deliverables:
      - hw1.ml -- functions that you implemented
      - hw1test.ml -- test cases for your functions
      - hw1.txt -- written assesment of every problem, thought process, etc
      - Note: copy the grammar type def into your file

