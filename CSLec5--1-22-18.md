<h1>Lecture 5</h1>

---


```c++

class String{
    public:
        String(const char* value = "");
        ~String();
    private:
        // Class invariant: 
        //  m_text points to a dynamically allocated array of 
        //      m_len + 1 chars
        //  m_len >= 0
        //  m_text[m_len] == '\0'
        char* m_text;
        int m_len;
    };


    String::String(const char* value){
        m_len = strlen(value);
        m_text = new char[m_len + 1];
        strcpy(m_text, value);
    }

    String::~String(){
        delete [] m_text;
    }

```

>Recall that in the above case, the String constructor acts as a default constructor if no argument is passed, because the constructor has a default value.

At this stage, the `String` constructor is not very robust. If the constructor receives as its input a dangling pointer, a null pointer/uninitialized pointer, or a character array with no zero byte, it will result in unpredictable behavior.

In the case of a null pointer input, the `strlen` function will execute undefined behavior, as will the `strcpy` function. To fix this, we can implement a special case in the constructor:


```c++

String::String(const char* value){
    if (value == nullptr)
        value = "";
    m_len = strlen(value);
    m_text = new char[m_len+1];
    strcpy(m_text, value);
}
```

Although it may seem strange that we are modifying `value`, which appears to be a constant. However, the argument `value` is actually a pointer to a constant `char`. We are simply changing which constant it points to. This should take care of our main problem.

---

How an object is constructed:
1. ---------- (We'll see this later) -----------------
2. Construct the data members, consulting the member initialization list.
      - if a member is not listed, if it is of a 
          + builtin type, it is left uninitialized
          + class type, it is default-constructed (if no default constructor, error!)
3. Execute the body of the constructor. 

How an object is destructed:
1. Execute the body of the destructor.
2. Destroy each data member
      * builtin type, do nothing
      * class type, call its destructor
3. ---------- (We'll see this later) ----------

Default destructor:

```c++
Type::~Type(){}
```

---

We now have to look at the process of copying objects.

Copying an object makes use of either the copy constructor or the assignment operator.

When a value is passed by value into a function, the copy constructor is called. The default copy constructor performs what is called a "Shallow copy", which does a bitwise copy of the value. If the object contains a pointer to an array, etc, it will only copy the value of the first element and not any subsequent ones. Copy constructor should be used whenever dynamic allocation is used.

```c++

class String{
    public:
        String(const char* value = "");
        String(const String& other);
        ~String();
    private:
        // Class invariant: 
        //  m_text points to a dynamically allocated array of 
        //      m_len + 1 chars
        //  m_len >= 0
        //  m_text[m_len] == '\0'
        char* m)text;
        int m_len;
    };


String::String(const char* value){
    if (value == nullptr)
        value = "";
    m_len = strlen(value);
    m_text = new char[m_len+1];
    strcpy(m_text, value);
}

String::String(const String& other){
    m_len = other.m_len;
    m_text = new char[m_len+1];
    strcpy(m_text, other.m_text);
}
```

This way, we correctly copy the dynamically allocated storage.

---

We have the copy constructor covered, so if a new object is assigned the values of another object, we chillin.

however, if we aim to copy an object into another already existing object, we need another function -- the assignment operator.

```c++

class String{
    public:
        String(const char* value = "");
        String(const String& other);
        String& operator=(const String& rhs);
        ~String();
    private:
        // Class invariant: 
        //  m_text points to a dynamically allocated array of 
        //      m_len + 1 chars
        //  m_len >= 0
        //  m_text[m_len] == '\0'
        char* m_text;
        int m_len;
    };


String::String(const char* value){
    if (value == nullptr)
        value = "";
    m_len = strlen(value);
    m_text = new char[m_len+1];
    strcpy(m_text, value);
}

String::String(const String& other){
    m_len = other.m_len;
    m_text = new char[m_len+1];
    strcpy(m_text, other.m_text);
}


String& String::operator=(const String& rhs){
    // if the objects are at the same address, 
    // the objects are the same. Skip the copy
    if (this != &rhs){
        delete [] m_text;
        m_len = rhs.m_len;
        m_text = new char[m_len + 1];
        strcpy(m_text, rhs.m_text);
    }
    return *this;
}
```

By default, the assignment operator acts like the default copy constructor, performing a shallow copy (copying the members). Since we want to have a new dynamically allocated character array for our string, we delete the old one and create a copy of the other object's character array.

The return type of the `operator` function is a reference to the object type. This is mainly so that chain operations work correctly (eg `str1 = str2 = str3;`)

We added an if statement to check whether the two addresses are the same, so that an object is not copied to itself (would cause errors).

But this code will cause errors if exceptions are thrown (for various reasons).

To solve this, we would implement a "swap" function, that uses a temp variable to copy one value to the other.

Modern implementation:

```c++
String& String::operator=(const String& rhs){
    // if the objects are at the same address, 
    // the objects are the same. Skip the copy
    if (this != &rhs){
        String temp(rhs);
        swap(temp);
    }
    return *this;
}
```