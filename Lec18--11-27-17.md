<h1>Lecture 18</h1>



``` c++
    class Target{
        public:
            Target(); // constructor
            bool move(char dir);
            void replayHistory() const;
            int position() const;

        private:
            int pos;
            string history;
            //Invariant:
            //      history consists of only Rs and Ls
            //      pos == # of Rs in history minus
            //             # of Ls in history
    };

    Target::Target(){
        pos = 0;
        history = "";

    }

    int Target::position() const{
        return pos;
    }

```

>The `const` flag after the function name in the prototype and the function definition signals to the compiler to check whether or not the function aims to modify the object it is called on. If the function does this, it will cause an error.

All member functions that do not modify the object it's called on should be declared with `const` as soon as they are defined. If you forget to do this right away, you are likely to forget.

A constructor, like the one defined above, tells the compiler how to properly initialize an object. In the above case, the `pos` will be assigned to 0 on declaration, not to a garbage value.

All constructors should be called with the format `ClassName()` and defined with the form `ClassName::ClassName()` without any return type or other flags.

---

The second half of the `Target` functions:
```c++
    bool Target::move(char dir){
        switch (dir){
            case 'R':
            case 'r':
                pos++; // this->pos++;
                break;
            case 'L':
            case 'l':
                pos--;
                break;
            default:
                return false;
        }

        history += dir; // this->histpry += dir;
        return true
    }
```

>IF there are no local variables with names that conflict with the data members of Target, you do not have to use the `this->` notation. 

```c++
    void Target::replayHistory() const{ // const because no value is changed
        for (int k = 0; k != history.size(); k++)
            cout << history[k] << endl;
    }

```

An interesting feature of C++ is that, when using the square bracket subscript notation, if the function it is called in is declared as constant, the char at the subsctipt will be returned, but if it is not declared as constant, a reference to the char that can be modified will be returned.


---

Recall that pointers can help

  * Implement pass by reference
  * traverse arrays
  * manipulate dynamic storage
  * represent relations in data structures

We are now interested in the third feature, the ability to manipulate dynamic storage. We can use this in the following manner:

```c++
    //...
    
    Target* targets[100]; // an array of pointers to Targets
    int nTarget = 0;
    while (nTarget < 100){
        *targets[nTarget] = new Target; // new generates a pointer to the 
                                        // object
        nTarget++;
    }



```

>The `new` flag returns a pointer to the object it is associated with.

Instead of allocating the memory for the targets and creating the objects at initialization, you are only allocating memory for the pointers to pointers to those objects. 

---


A comparison between C++ and Java:

C++ | Java | Explanation
---|---|---
`Target* tp = nullptr` | `Target tp;` | Declares a garbage pointer to the object's type
`tp = new Target` | `tp = new Target()` | Assigns the pointer to a new memory address
`tp->move('L')`|`tp.move('L')`| Changes the value of pos
`Target t` | No Java equivalent | creates an object of type Target

---

```c++
    void playGame(){
        Target* targets[1000];
        int nTargets = 0;

        //...

        for ( int k = 0; k < 3; k++){
            targets[nTargets] = new Target;
            nTargets++;
        }

        int i;
        // ... something that gives i the value 1
        targets[i]->move('L');
        // ...
        targets[1]->move('L');
        // ...
        targets[1] = targets[2];
        nTargets--;
    }

```

This function serves to represent a round of the game. Notice that after assigning `targets[1]` to `targets[2]`, we lose our access to the variable that was stored in `targets[1]`. The value still exists in allocated memory, however. 

This is known as a garbage value. Too many garbage variables may causes the program to crash as the memory fills with unused values.

Some languages handles this by a process known as garbage collection. The runtime environment will check for memory locations that are no longer pointed to and release it back to the program.

C++ gives this responsibility to the programmer. To return the memory location to the OS, we use the syntax:

```c++
    delete targets[1]; // delete pointerToObject;
    targets[1] = targets[2];
```

The delete keyword releases the address to the OS and deletes the object at that address, meaning that the pointer can be reassigned to a different value. This is called a dangling pointer.

If you forget to use delete keyword in a situation like this, it can result in a  memory leak.

Memory leaks can be very dangerous. A memory leak on a mars probe could have caused millions in damage, but was thankfully caught in time.

To handle any memory leaks that might be cause by the function above, we should do the following:

```c++
    // ...
    for (int k = 0; k < nTargets; k++)
        delete targets[k];
    
```

This code `delete`s all the objects pointed to by the `targets` array.

---


```c++

    class Pet{
        public:
            Pet(int initialHealth, string petName);
            string name() const;
        // ...

        private:
            int health;
            string nm;
    };

    Pet::Pet(int initialHealth, string petName){
        health = initialHealth;
        nm = petName;
    }

    string Pet::name(){
        return nm;
    }

    int main(){
        Pet dog1(10, "Fido");
        cout << x.name() << endl;
    }

```

Notice that there are three calls to the variable `nm`. To avoid both errors and confusion, the public data member should have the more natural name, and any other calls to the name should be different.

Some conventions to do this would be `name_` or `m_name` (implying `member`)

So, 

```c++

    class Pet{
        public:
            Pet(int initialHealth, string petName);
            string name() const;
        // ...

        private:
            int m_health;
            string m_name;
    };

    Pet::Pet(int initialHealth, string petName){
        m_health = initialHealth;
        m_nm = petName;
    }

    string Pet::name() const{
        return m_name;
    }

    int main(){
        Pet dog1(10, "Fido");
        cout << x.name() << endl;
    }

```

---

<h4>Problems with constructors</h4>

Since the constructor above has 2 parameters, you must use two arguments to initialize one.

```c++
int main(){
    Pet x; // won't compile
    Pet y [10]; // won't compile
}

```

To combat this, we could use explicit declarations or use pointer arrays.


```c++
int main(){
    Pet x(10, "snowflake"); 
    Pet* y [10]; 
}

```