<h1>Lecture 7</h1>

---

<h3>Agenda</h3>

  * Prelims
  * Recaps
  * Pumping Lemma
  * Equivalence of Models
  * Classes of Languages
  * Closure Properties of Classes of Languages
  * If time, Previews of Material for after Midterm 1

---

<h3>Pumping Lemma</h3> 

  * Property of every lanauge in the fam of finites state languages
      - allowws us to prove that a given lang is NOT finite state
  * Pumping Lemma for FSLs:
      - If L is a finite state language (acc'd by a DFA or NFA, or rep'd by a Reg. Exp) then there exists a constant, p, that depends *only* on L such that, &forall; s &isin; L, if |s| &ge; p, then
          + There exist substrings x, y, z such that s can be broken down s = xyz and x, y, and z obey the following ocnstrianst:   
              * x &isin; &Sigma;<sup>&ast;</sup>, y &isin; &Sigma;<sup>+</sup>, z &isin; &Sigma;<sup>&ast;
              * etc

<h3>Guidinance on Using the Pumping Lemma</h3>

  * A proof using the PL must contain the four essential elemetns of this kind ofproof:
      - Selecting an app string s
      - correctly using the constraints on x, y, and z imposed by the lemma
      - Showing that you have covered all the possible cases of x, y, and z
      - Using sound and complete logic in each case to show that s' cannot be in L
  * Notes:
      - you can only give a name to p; you cannot assume anything about p other than p &gt; 0 and whatever you can infer aboiut p from the definition of the language
      - You can and must choose stging s to be a specific string in L, You can choose any string, s, you want, as long as it is in L and |s| &ge; p
          + some choices of s may not leasd to the desired contradiction and some may work but make your job drastically more difficult than necessary
      - You cannot assume anything about how s is divided into xyz, other than the constrains imposed by the lemma. In particular, you cannot say "Let x = ..." or "Let xy = ..." here the value of the ...'s is of your choosing. 
          + You have to consider every possible way that s could be divided into xyz
          + the way s is divided into xyz does not have to line up in any way with the format of the strings in the language
              * eg the language is defined as "{w = rst | substrings r, s, t, ...}", you CANNOT assume that x = r, y = s, z = t, etc.

---

<h3>Set representations</h3>

  * __F7.1__
  * This principle applies to any number of sets, as long as there is a directed cycle of subsets in this way
      - you can get from any node back to itself
  * Extends to the regular language model
      - DFA &sube; NFA &sube; GNFA &sube; RegExp &sube; DFA
  * Arrow notation (&rarr;):
      - A &rarr; B &rArr; A &sube; B
  * GNFA &sube; NFA is kind of hard to do
  * RegExp &sube; GNFA
  * Any finite state language, in any of these forms, can be constructively modified into any other state.
      - `grep` traditionally was a transformation from a RegExp to an NFA to a DFA
          + convert a pattern to something that can be executed by a machine with no human interference required in the process

---

<h3>NFA &sube; DFA</h3>

  * __F7.2__
  * NFA N that recognizes language L
      - Construct DFA M such that the language recognized by M is L
  * &delta;*(q<sub>0</sub>, w) = S.
      - Note: P(Q) represents the power set of Q (set of all subsets)
          + Each state in the DFA is a subset of the states of the NFA
      - For every state that is in the set of states R, we are going to compute the set of states that the NFA could go to from R in the NFA
  * F' would then be any set of states that contains a final state from the NFA
      - F' = all subsets, T, of Q such that T &cap; F &ne; &empty;

---


