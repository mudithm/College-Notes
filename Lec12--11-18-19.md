<h1>Lecture 12</h1>

---

<h5>Scheme Syntax</h5>

![Scheme Syntax](https://cdn.discordapp.com/attachments/581226308672159747/646110077899505678/20191118_141030_HDR.jpg) 

---

<h5>Special Forms</h5>

  * `(if A B C)` 
  * `(quote a)`
      - returns the thing that is passed as an argument as it -- NOT as data, etc.
  * `(lambda (args) body)`
  * `(define name value)`

<h5>quasiquoting</h5>

```scheme
`(if ,I
    "hello"
    ,E)
```

Quasiquote, "`", evaluates only the terms that are preceded by a comma.
,@ -- dequote and flatten

---

<h5>Program syntax</h5>

```scheme

(define pi 3.14159)
(define id (lambda (x) x))
(define cddr (lambda (x) (cdr (cdr x)))))
; this is equivalent to
(define (cddr x) (cdr (cdr x)))

; functions that take multiple (or unspecified) arguments
(define printf (lambda (format . args) ... ))

(printf "%d=%s\n" 37 "hello")
; args are bound to a list, in this case (37 "hello")

; more compact definition
(define (printf format . args) ... )

; another example, that takes 0 or more args
(define f (lambda x ...))
; equivalent to
(define (f . x) ...)

; list function
(list 3 (cons 4 5) "abc")
=> (3 (4 5) "abc")

; equivalent
`(3 ,cons(4, 5) "abc)`
=> (3 (4 5) "abc")

```

---

<h5>`and` and `or` functions</h5>

```scheme
(and E1 ... En)
; evaluates expressions E1, ... En left to right, yields #f immediately if
; one of the expressions is false, otherwie yields the value of the last
; expression

(or E1 ... En)
; evaluates expressions E1, ... En left to right, yields return value
; immediately if one of the expressions is true, otherwise yields #f

; such a short circuit evaluation would not be possible for xor, since
; it relies on all the expressions passed to it

; main difference between these and C/C++: they do not return booleans, 
; they can return values.
```

---

<h5>Standard Functions</h5>

  * `(eq? a b)` 
      - 'pointer' equality
          + if two things refer to the same memory address
          + If you pass an integer or something, your code should handle both the cases, where it returns false bc two separate objects or true bc same reference in some integer table
      - O(1)
  * `(eqv? a b)` 
      - equality of the "immediate" contents of the things we're trying to compare
          + looks at the object that the pointers are pointing at, but stops there
      - O(N)
  * `(equal? a b)` 
      - recursive comparison
          + keeps looking until it fully inspects the data structures of each of its arguments
          + calls itself recursively for the structures, calls `eqv?` on the leaves
      - can be infinite
  * `(= a b)` 
      - numerical equality (args must be numbers)
      - O(1)

----

<h5>`set_car!` / `set_cdr!`</h5>
 
  * `(set_car! p v)` 
      - replace the head of the list `p` with the value `v` 
  * `(set_cdr! p v)` 
      - replace the tail of the pair `p` with the value `v` 
  * This is dangerous, because you can assign a pair's tail to its head, or something like that, creating an infinite list


---

<h5>Wrappers</h5>

```scheme
(define ct 0)
(define (consct a b)
    (set! ct (+ 1 ct))  ; set! is like assignment
    (cons a b))
(set! cons consct)  ; will not work, since cons is used in the definition
                    ; of consct
(let ((f cons))
(define (consct a b)
    (set! ct (+ 1 ct))  ; set! is like assignment
    (f a b)))
(set! cons consct)

; another way to do this:

(define (wrap f)
    (lambda x
        (set! ct (+ 1 ct))
        (apply f x)))       ; builtin function that calls a function with the
(f x)                       ; number of arguments in x
(set! cons (wrap cons))
```

---

<h5>Identifiers in Scheme</h5>

Identifiers in Scheme are either:
  * symbols
  * variables
      - (lambda (x) x)
      - have scope and can be declared
  * syntactic keywords
      - also have scope and can be declared
      - can be used to define functions/procedures and macros
          + macros are run at compile time, and replace/expand segments of code / tell the compilers what to compile

```scheme
(define-syntax and 
    (syntax-rules ()
        ((and) #t)
        ((and x) x)
        ((and x y ...)(if x (and y ...) #f))
    ))

(define-syntax or
    (syntax-rules ()
        ((or) #f)
        ((or x) x)
        ((or x y ...) (if x x (or y ...))) ; this line can be very inefficient,
                                           ; since it might evaluate the same
                                           ; arguments more than once
        ((or x y ...) (let ((v x))
                        (if v v (or y ...)))))) ; this results in better perf,
                                                ; but if v is already defined
                                                ; somewhere, this might cause
                                                ; issues.
        ; when scheme expands macros, it respects the scope of variables.
        ; So, it will treat variables local to the scope of the macro as if
        ; they are separate (equivalent to renaming them to something else)
        ; this solves the problem of capture
```

