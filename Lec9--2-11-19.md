<h1>Lecture 9</h1>

---

<h4>Critical Section</h4>

  * Set of insns that must act indivisibly on an objact
  * Goal: allow temporary inconsistency
  * Enforcing:
      - mutual exclusion
      - bounded wait (fairness)
  * Goldilocks principle: find the minimal (but safe) critical section
      - Look for WRITES to shared state (Reads will not mess with eachother)
          + not just writes to buffers, but changing variable values, etc
      - Expand them to include dependent reads
          + reading from shared state in order to affect a write to shared state/decision to write to shared state
      - If too large, causes bottlenecks
      - if too small, causes correctness issues

---

<h4>Uniprocessor Critical Sections</h4>

  * Cooperative scheduling
      - No need to yield
  * Preemptive scheduling
      - disable scheduling (disable_clock_intrs())
      - perform critical section
          + no yielding
      - enable scheduling (clock inst())

---

<h4>Hardware Lock Elision</h4>

  * An intel thing

```
 lock:      
        movl $1, %eax
 try:       
        acquire lock xchngl %eax, mutex
        cmp $0, %eax
        jmz try
        ret
```

  * only for simple instructions
  * predictively assumes that the lock belongs to you, and performs like a normal failed branch prediction if it turns out that the lock didn't (skips the loop)

---
 
