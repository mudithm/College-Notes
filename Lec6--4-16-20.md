<h1>Lecture 6</h1>

---

<h3>Agenda</h3>

  * Preliminaries
  * Recaps: HW2 and CFGs
  * Equivalence of Models
  * Generalized NFA (GNFA)
  * Pumping Lemma

<h3>Homework 3 Question</h3>

  * Problem 4
      - An &epsilon; means that it can move one state to another without any input
          + in this q, the empty string is accepted

---

<h3>Context-Free Grammars</h3>

  * CFG G=(V, &Sigma;, R, S)
      - (Variables, Terminals/Alphabet symbols, rewriting rules, start variable)
      - w &isin; L(G), w &isin; &Sigma;<sup>*</sup>
  * Derivations
      - Left-most and Right-most
          + Exactly one left-most derivation, exactly one rightmost derivation, corresponding to exactly one tree.
      - It is entirely possible that the same string w in the same grammar is derived in an entirely different manner that results in a very different tree, with the same leaf nodes. This tree will have its own unique left-most and right-most derivations.
  * If there is more than 1 tree for w in G: w is "ambiguous in G"
      - Equivalently, if there is more than 1 right-most derivation or more than one left-most derivation.
  * If one or more string generated by G is ambiguous, "Grammar G is ambiguous"
  * if ALL grammars for a language L are ambiguous, then "L is inherently ambiguous"
  * It is difficult to prove a grammar/language is NOT ambiguous, but it is relatively easy to prove that it is, just provide an ambiguous string

---

<h3>Inherently Ambiguous languages</h3>

  * How can you check if *all* grammars for a language are ambiguous?
      - This is very, very difficult to prove -- so we won't have to worry about that

---

<h3>Generalized NFA's</h3>

  * __F6.1__
  * Script R: All possible regular expressions over &Sigma;
  * Another way to rep a graph: transition from state p to state q on a regular expression
      - transition from p to q on any sequence of 0 or more input symbols that match the regular expression R
  * 1D &equiv; 1 followed by the regular expression D
  * Note: not allowed to have transitions into the initial state, nor out of the final state
  * Also, there must be a path from the initial state to any other state, and from any state to all other intermediate/subsequent/parallel states 
      - this can be the empty set &empty;
  * Also all states need self loops lol, besides the initial and the end
      - Superseding rules: nothing goes into the initial, nothing comes from the final/accepting

<h3>Mathematical Def of Generalized NFA's (GNFA's)</h3>

  * Let Script R denote the set of all Regular expressions
  * N = (Q, &Sigma; &delta; q<sub>0</sub>, q<sub>F</sub>) where
      - Q, &Sigma;, q<sub>0</sub> are exactly as DFA and NFA
  * q<sub>F</sub> is the final, accepting state (only one accepting state in a GNFA)

---

<h3>Pumping Lemma</h3>

  * Property of every language in the family of finite state languages, which allows us to prove that a given language is not finite state
  * Pumping Lemma for FSL's:
      - If L is a finite state language (accepted by a DFA or NFA or represented by a Reg. Exp) then there exists a constant, p, that depends only on L such that for all s &isin; L, if |s| &ge; o, then:
          + There exist substrings x, y, z such that s can be broken down s = xyz and x, y, z obey the following constraints:
              * x &isin; &Sigma;<sup>&ast;</sup>, y &isin; &Sigma;<sup>+</sup>, z &isin; &Sigma;<sup>&ast;</sup>
              * |y| &ge; 1
              * |x| + |y| &le; p
              * for all i &ge; 0, xy<sup>i</sup>z &isin; L


<h3>Example</h3>

  * &Sigma; = {a, b}
  * L = {ww | w &isin; &Sigma;<sup>&ast;</sup>}
  * We are going to prove, by contradiction, that L is not a FSL
  * Suppose L were a FSL. Then the Pumping Lemma (PL) would apply to L. So, &exist; p such that &forall; s, |s| &ge; p. We can write s = xyz, where |xy| &le; p. |y| &ge; 1, and &forall; i &ge; 0, xy<sup>i</sup>z &isin; L.
      - We need to prove that the for all (&forall;) statement is false
      - find a string that shows a contradictions
  * Choose s = a<sup>p</sup>ba<sup>p</sup>b &isin; L
      - clearly, |s| &ge; p
      - w = a<sup>p</sup>b
      - We now need to disprove "there exists" in the statement:
          + There exists x, y, z such that s=xyz
  * Since |xy| &le; p, we know xy consists entirely of a's and it is at the beginning of the first a<sup>p</sup> (since it is at most p symbols long)
  * So, x = a<sup>n</sup>, n &ge; 0, y = a<sup>m</sup>, m &ge; 0
      - z = a<sup>p - (n + m)</sup>ba<sup>p</sup>b
  * Consider, then, the string xy<sup>0</sup>z
      - this is a<sup>n</sup>a<sup>p-n-m</sup>ba<sup>p</sup>b = a<sup>p-m</sup>ba<sup>p</sup>b
      - This is a contradiction, because for m != 0, this is not in the language L (m is at least 1, since it is the length of y, which is &ge; 1). So, since the assertion is false for i=0, this is a contradiction, and therefore L cannot be a finite state language.
  * Notes: 
      - s must be in L
      - Must be on the "edge" of language L
          + similar to strings that are not in the language