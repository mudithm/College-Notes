<h1>Lecture 14</h1>

---

For every variable declared, the compiler will put it somewhere in memory.

Two cancellation rules with pointers:

``` c++
    ...
    *&x; // This returs the object pointed to by the pointer that 
    // leads to x, or just x

    &*p; // This returns the pointer to the object that p is pointing 
    //to (This only works if p is a pointer), or just p
```


---

When iterating using pointers, the following logic applies:

``` c++
    int da [10];

    for (dp = &da[0]; dp < &da[MAXSIZE]; dp++){  /* (the pointer dp is less 
        than the element of the last element in the array) **** */
        *dp = 3.6;
    }

```
The code above will set each element of da to 3.6, incrementing the pointer with each iteration.

How this works:
``` c++
    dp = &da[i];
    dp++ = dp + 1;
    dp++ = &da[i] + 1;
         = &da[i+1];
         /* (What this actually does is add 8 bytes to the address 
            referenced by dp.) The compiler will handle this*/
```

The same logic applies when using the -- operator as well.
```c++
    dp = &da[i];
    dp-- = dp - 1;
    dp-- = &da[i] - 1;
         = &da[i-1];
         /* (What this actually does is subtract 8 bytes from the address
            referenced by dp.) The compiler will handle this*/
```
Note: the behavior is undefined if the i is not in the array.


---


This sort of pointer addition has limited funcitonality. If you try to increment a pointer to an object that is not in an array, it will result in undefined behavior.

**** Pointers are also subject to the comparison operators.

Note: The value after the end of an array is always reserved. So, if for whatever reason a pointer containing an address just after the end of the array is referenced, it might not cause an error.

Another Note: if you use an array name in your pointer reference instead of a subscript, eg `dp = da` instead of `dp = &da[0]`, they are equivalent in most cases. It appears as though you are creating a pointer to the first element of the array.

---


In the 1970s, traversing arrays using pointers was more efficient. Advances in compiler technology, however, have made the integer subscript method of traversing arrays more efficient (Note that his does not necessarily hold true for other data structure). However, the belief that pointers are the more efficient are still widely held by those whose computer science knowledge is outdated.


---

``` c++
    int m = lookup(b, 10, "zebra"); // is equivalent to 
    int n = lookum(&b[0], 10. "zebra");
```

As a parameter to a function, `type[]` is equivalent to `type*`

If you have a pointer, you can subscript off of it, by following the object that the pointer plus the subscript points to.

for example:

``` c++
    a = &b;
    a[5]; // a pointer to an object 5 "elements" after the memory address of b.
```
 
In this vein, to iterate through a subset of an array beginning at some arbritary value i,

``` c++
     int m = lookup(&b[i], 10 - i, "zebra");
    //or, equivalently,
    int n = lookup(b + i, 10 - i, "zebra");
```
 
So long as i falls within the bounds of b, this is legit.


---

A neat feature of C++:

Assuming a valid array with i and k in its elemetns, ` &d[i] - &d[k] ` will return the difference between the subscripts of the two elements