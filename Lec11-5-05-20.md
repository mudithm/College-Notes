<h1>Lecture 11</h1>

The last lecture was the midterm, I didn't skip it lol

---

<h3>Agenda</h3>

  * Midterm solutions and midterm performance
      - Grammar that has only one variable on each side of a rule:
          + linear context-free grammar
          + cannot represent all context-free langauges
              * ie can't represent {a<sup>i</sup>b<sup>j</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;    c<sup>k</sup>d<sup>l</sup> | i = j and k = l}
          + Generally, CFG's *can* represent
              * {a<sup>i</sup>b<sup>j</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;c<sup>k</sup>d<sup>l</sup> | i = j and k = l} because concatenated
              * {a<sup>i</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b<sup>j</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c<sup>k</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d<sup>l</sup> | i = l and k = j} because nested
          + *cannot* represent
              * {a<sup>i</sup>b<sup>i</sup>c<sup>i</sup>} because three matches
              * {a<sup>i</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; b<sup>j</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; c<sup>k</sup> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; d<sup>l</sup> | i = k and j = l} because the two matches are intermixed
  * intro to (N)PDA model
  * Closure Properties (of Families of Languages & Application to Prove Language not in a Family)
  * Pumping lemma for CFL's
  * Variations on Automata (including Deterministic PDA)

---

<h3>(N)PDA</h3>

  * __F11.1__
  * Push-down automata: comes from the terminology of the stack
  * Only the top symbol is accesible    
      - "head" is accessible to the machine
  * Stack alphabet (&Gamma;)
      - {&epsilon;} &nsube; &Gamma;
  * Stack actions:
      - Push
      - Pop
      - Read
          + read the top of the stack
          + sometimes called a swap -- pop and push in the same step
      - Check if the stack is empty

<h3>Implementation</h3>

  * __F11.2__
  * Machine actions: (things that happen on each individual move of the machine)
      - Read input (or don't care)
      - Read top of stack (or don't care)
      - Change state
          + q &rarr; q'
      - Stack action
  * What would a transition look like in this diagram?
      - in state q, if the next symbol is S<sub>1</sub>, you can move to state q' and if element a is on top of the stack, replace it with b.
      - a stack symbol a = &epsilon; indicates that we don't care what element of the stack alphabet is on top
  * Example
      - &Sigma; = {a, b}
      - &Gamma; = {  }
      - L = {a<sup>n</sup>b<sup>m</sup> | n &ge; m &gt; 0}
  * Pseudocode
```
0. Mark the bottom of the Stack (push "$" to the stack)
1. For each input a push one &Gamma; symbol until input = b
2. For each input b pop one &Gamma; symbol until:
    a. reach end of input  (accept n &gt; m)
    b. see the bottom of the stack (accept, n = m)
    c. see the bottom of the stack, but there is more input (m > n, do not accept) 
```

  * __F11.3__ 
  * If the machine sees a b before an a, since there is no specified transition for that situation, the machine blocks like an NFA would
  * Since there is also no specified transition for receiving a b on an empty stack (the dollar sign only left), this also blocks and rejects.
      - if the machine is in the middle of an input and doesn't know what to do next (no transition defined for the scenario) the computation rejects and blocks.
  * Note: the $ convention is not really used here (since NO transitions are defined from the accepting state for an empty stack)