<h1>Lecture 14</h1>

---

<h4>STL, cont</h4>

Iterators:

```c++
for (list<int>::iterator p = li.begin(); p != li.end(); p++)
{
    cout << *p << endl;
}

```

The iterator type acts similarly to a pointer and allows for more robust traversal of `STL` containers.

You cannot treat it like a normal pointer (ie you can't reassign it to a pointer's value) but you can dereference it, increment it, decrement it, and use it as a parameter for `STL` functions.

---

The `begin()` function "points" to the first element in the container (or to `end()` if the list is empty, and the `end()` function returns a position just after the last element of the array.

---

The `insert()` follows the structure `(where to put the element, what to put there)`. The "where to put" part refers to the iterator elemnet after the place you want to put the element.

`Insert()` returns an iterator pointing to the newly inserted node.

When you insert into a list, it will not result in a reallocation of the container, but if you insert into a vector when it is at its capacity, it will have to reallocate its data. This will likely make the iterator invalid, so it is important to set the value insert returns to the iterator, or the iterataor will be dangerous to follow.
 
---

The `erase()` function removes the object at the iterator argument and returns the iterator pointing to the next element of the container.

---


```c++
int* find(int* b, int* e, const int& target)
{
    for (; b != e; b++)
        if (*b == target)
            break;
    return b;
}

```

This algorithm searches through an array of integers and searches for a target. If the target is not in the array, it returns a pointer to the position after the last element of the array (`int* e`).

We wrote it this way so that it can be more easily translated into a template fucntion.

```c++
template<typename T>
T* find(T* b, T* e, const T& target)
{
     for (; b != e; b++)
        if (*b == target)
            break;
    return b;
}
```

This should work for any array.

Note that strings surrounded by characters are cstrings, not c++ strings. So, passing find(stringArr, stringArr+4, "Hello") would not compile.

This can also be modified to work for STL containers (since iterators are not truly pointers, modifications must be made).

This might make it more clear:

```c++
template<typename Iter, typename T>
Iter* find(Iter* b, Iter* e, const T& target)
{
     for (; b != e; b++)
        if (*b == target)
            break;
    return b;
}
//...
vector<int>:: iterator r = find(v.begin(), v.end(), 42);
//....
```

This will work so long as the target is of the type pointed to by the iterator, and the type passed as Iter is a pointer or iterator.

Other STL functions:

  * sort(vi.begin(), vi.end())
  * int count (vi.begin(), vi.end(), 0)
  * reverse (vi.begin(), vi.end())

The reason for using the STL functions is that they are more well-known to the avg C++ programmer, so it is easier for other programmers to understand and adapt your code

---

We can extend the notion of template functions further, allowing them to replace functino names as well.

For example:

```c++

template<typename Iter, typename Func>
Iter find_if(Iter b, Iter e, Func f)
{
    for (; b != e; b++)
        if (f(*b))
            break;
    return b; 
}

bool isNegative(int k)
{
    return k < 0;
}

bool isEmpty(string s)
{
    return s.empty();
}

int main()
{
    //...
    vector<int>::iterator i = find_if(i.begin(), i.end(), isNegative);
    //...
    vector<string>::iterator s = find_if(s.begin(), s.end(), isEmpty);
    //...
}
```

The "type" of the funcion passed to find_if is a pointer to a function.

In the case of `isNegative`, it is a pointer to a function that takes an integer and returns a bool

In the case of `isEmpty`, it is a pointer to a function that takes a string and returns a bool

Since in the find_if function f is called with an argument, the compiler will try to pass that argument to whatever name is passed to Func. If this works, we chillin. If it is a pointer, it will pass the argument to the fucntion that is pointed to. Otherwise, it will cause an error.

Many STL functions have this _if syntax or similar syntax that allows for a predicate check.

For example, the `sort` function can take a predicate at its third argument that tells it how to order the elements of the array. (ie less than, etc.)

`sort(vec.begin(), vec.end(), isGreater)` will sort in decreasing order.

---

