<h1>Discussion 1</h1>

---

<h3>What we'll cover</h3>

  * Calculating the error probability
  * Chernoff Bounds
  * Modular Arithmetic
  * Basic complexity classes (P/NP, etc)

---

<h3>Basic Probability</h3>

  * Unbiased coin
      - `Pr[coin = heads] = 1/2` 
  * Toss the coin 10 times, independently
      - tossing a coin doesn't depend on the outcome of any other toss
  * What is the prob that no heads appear in 10 independent trials?
      - equivalent to 10 tails = (1/2)
      - __D1.1__
      - relies on the independence assumption, meaning that the cond flips do not depend on each other

<h3>Expectation</h3>

  * X<sub>1</sub>, X<sub>2</sub>, X<sub>3</sub>,..., X<sub>n</sub>
  * X<sub>i</sub> &#8712; {0, 1} &#8704; i
  * X<sub>i</sub> = 0 implies tails, X<sub>i</sub>  = 1 implies heads.
  * X' = X<sub>1</sub> + X<sub>2</sub> + ... + X<sub>100</sub>  
  * Pr[no heads] = Pr[X' = 0] 
  * E[X] = "expected value of X"
      - = &sum; Pr[X=n]*n
  * E[# heads in 100 coin tosses] = &sum; Pr(x=1/2)*1

<h3>Biased coin</h3>

  * Pr[coin = heads] = 2/3
  * Pr[coin = tails] = 1/3
  * 100 coin tosses
      - Pr[no heads] = Pr[all tails] = (1/3)^100
      - Pr[no tails] = Pr[all heads] = (2/3)^100

---

<h2>Homework Problem</h2>

---

<h3>Deterministic and Randomized Algs</h3>

  * Deterministic Machines (algorithm)__D1.2__
      - Algorithm isn't internally tossing any coins
  * To test whether a number is prime
      - 70's: Miller-Rabin algorithm
          + Took in a number, tossed coins, and returned a prime/composite(not prime) output
          + The same inputs can result in different output
      - 2000's: deterministic algorithm found for this
  * Randomized Algorithm
      - Algorithms that "toss coins" (have some degree of randomness)
  * Point: sometimes randomness helps
      - Important for Crypto bc we want the adversary to be as powerful as possible (randomness gives them more power)

<h3>RP</h3>

  * RP: randomized Polynomial
  * a language L = set of strings
  * L = PRIMES = {set of primes}
  * Given a number, x, is x  &#8712; PRIMES = L?
  * Determ. alg for L
      - If x  &#8712; L, alg outputs Yes always
          + Pr[algo accepts]=1
      - If not, alg always outputs NO
          + Pr[algo accepts]=0
  * Random alg for L
      - if x &#8712; L, Pr[algo accepts] >= 2/3
      - else, Pr[algo accepts] = 0
  * Hw question:
      - how can we boost the success probability of sch an RP algo?
      - How to get 
          + if x &#8712; L, Pr[algo accepts] = 0.999
          + else, Pr[algo accepts] = 0
      - Since if the thing is not in the language it always rejects, we know that if there is ever an accept, it must be in the language
          + So for k trials, Pr[all k rejects] = Pr[one reject]^k
              * as long as the trials are indep
          + =(1/3)^k
```
    Pr[accept] = 1-Pr[reject] > 0.99
               = 1-(1/3)^k . 0.99
    Solve for k          
```

<h3>Co-RP</h3>

  * If x &#8712; L, Pr[accept] = 1
      - Pr[reject] = 0
  * else, Pr[accept] < 1/3
      - Pr[reject] >= 2/3
  * both RP and Co-RP are examples of One-Sided error

---

<h3>BPP (Two-sided error)</h3>

  * BPP: Bounded Probabalistic Polynomial
  * If x &#8712; L, Pr[accept] >= 2/3
  * else, Pr[reject] >= 2/3
  * __D1.3__
      - The problem with this is because the alg can error on both sides
      - For a chernoff bound, the intuition is that the probability of the expected value should be greater than probabilities of less expected values  
          + ie, if you flip 100 unbiased coins, you'd expect that 
              * Pr[50 heads] > Pr[60 heads] > Pr[70 heads], etc.
          + Formal def in figure
              * Basically, this tells us that the farther we get from the expected value, the more the prob changes from the expected, exponentially so.
  * How to amplify a buggy BPP machine
      - __D1.4__

---

