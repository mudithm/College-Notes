<h1>Lecture 4</h1>

---

<h3>Why we'd want to se a join</h3>

  * Normalization
  * Separating out concerns


<h3>Natural join</h3> 

  * join based on common attribnutes (attrubutes common to both relations are equal to each other)
  * If we try to join two relations that have NO common attributes, 
      - we just get the cartesian product
  * If we try to join to relations that have no common values of attributes, 
      - we get the empty set
  * natrual joins are associative

<h3>Other joins</h3>

  * joins that combine tuples using equalityy only (the equals sign) are called equijoins
  * there are other joins that use other operators

<h3>Theta join</h3>

  * Takes the cartesian product and apply a filter
  * If there are two columns with the same name in both relations, you keep both of them in the result. You will have to project the column you want.


<h3>Rename operator</h3>

  * In SQL, derived table alias
  * &rho;<sub>new</sub>(old)
      - rename a relation
  * &rho;<sub>new/old</sub>(Relation)

<h3>Union Op</h3>

  * &cup;
  * Must have the same number of attributes and the same names (you can rename them first if you need to)

<h3>Aggregation</h3>

  * <sub>(attributes to agg over)</sub>&gamma;<sub>(Operator(s) to use)</sub>(attribute to use the operator on)

---

<h3>The relational algebra vs SQL</h3>

  * Relational alg is about sets, SQL can have *multisets* or *bags*
  * Other Rel Ops
      - Left, Right,l Full Outer join
      - Left and Right Semijoin
      - AntiJoin
      - Division
  * These can be written using what we already know

---

<h2>SQL Data Types</h2>

---

<h3>Why use PostgreSQL</h3>

  * largely ANSI SQL compliant
  * open-source
  * query execution plans are readable by user
  * real security and authorization model
  * extensible and flexible type system similar to a programming language
  * is ACID compliant, has more modes of replication, etc
      - More features than most other SQL variants

<h3>The Data Definition Language</h3>

  * defines
      - Schema
      - types of attrs
      - integrity constraints, etc

---

<h3>ANSI SQL TYPES</h3>

  * numeric
  * strring/text
  * binary
  * dates and times

<h3>Numeric</h3> 

  * int
  * smallint
  * numeric(p, d)
      - fixed-point number containing p digits total, d of which are after the decimal sign
  * real, double precision: floating point and double precision floating point, machine dep't precision
  + float


<h3>String</h3>

  * char(n) -- fixed-length character string with a length of n characters (like a byte array)
  * varchar(n) -- variable length with a max of n (like a std::string)

<h3>Dates and Times</h3>

  * Date
  * Time
  * Timestamp (combo of the two)
      - timezones are implementation specific

<h3>The NULL value</h3>

  * unspecified

---

<h3>PostgreSQL types</h3>

  * Integer types
      - smallint (2 bytes)
      - integer (also called int) (4 bytes)
      - bigint (8 bytes)
  * Fixed-point types
      - DECIMAL(p, d)
          + p is the precision and d is called the scale
      - 'NaN'
          + greater than anything else in the tables
      - numeric and decimal are slow in Postgres, but there are times where they are necessary
  * Floating point types
      - real
      - double precision
      - Dangerous to compare these types
          + there is also an Infinity and -Infinity
      - other caveats
          + rounding may occur if the precision is too high
  * char and varchar
      - char(n) and varchar(n) can store at most n characters
          + storing a char(4) in a char(2) variable will truncate the last two characters in the char(4)
  * Binary Data
      - bytea, either hex or escape format
  * boolean type
      - True/false, t/f, y/n or 1/0
          + case insensitive and can have spaces before, etc
  * Bitstrings
      - bit(n), varying(n)
          + like char and varchar
  * Date
      - timestamp
      - timestamptz
      - timetz
          + time zone time
      - interval
      - preferred format: year-month-day 04:00:00 PST
      - CURRNET_DATE and CURRENT_TIME, or LOCALTIME, LOCALTIMESTAMP (UTC Default)
  * ENUM
      - in MySQL, string represented internally as an integer
      - in PostgreSQL, it's an actual type
  * Time and Space
      - determine if set of points is within some polygon on a map
          + geofencing, reverse 911
      - Determine where two polygons overlap/intersect (triangulation?)
      - determine which points lie along a line
      - finding points within a radius
  * JSON and XML
      - native storage and retrieval of JSOn and XML and provides functions and syntax for traversing the document structure
      - Allows us to index on a particular key nested in teh JSON
      - Common to include a column that contains miscellaneous attributes in something like a JSON blob