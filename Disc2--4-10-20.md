<h1>Discussion 2</h1>

---

<h3>BPP Setting</h3>

  * __D2.1__
  * Probability that the macine makes a mistake is 1/3, prob that it is correct is 2/3
  * Generally, E[x] = 
  * For X
      - X<sub>i</sub> = 1 if on the ith run, machine makes a mistake
          + 0 otherwise
      - The expectation of each run is the same since they are independent trials
  * __D2.2__
      - Chernoff Bounds
      - We want to find the upper bound in terms of k so that we can solve for a k that satisfies our chosen &epsilon;
          + The upper chernoff bound will be in terms of k
      - Once we fill in the numbers, we will get a  minimuum val of k.

---

<h3>P/Poly</h3>

  * __D2.3__
  * P/Poly is a class that allows you to get rid of probability in computations, proven by BPP &sub; P/Poly
  * Does P &sub; P/Poly?
      - Yes
      - an algorithm can be written in circuits, use the same for all input lengths.
  * Does P/Poly &sub; NP?
      - NO. P/Poly contains much more

<h3>Adleman theorems</h3>

  * BPP &sub; P/Polys
  * Pf: __D2.4__
      - Given a BPP, want to construct a circuit family for all input lengths that never makes a mistake.
      - Step 1: amplification to reduce error below 1/2<sup>n+1</sup>
      - Step 2: want to make it so that the mistakes are irrelevant 
          + design circuit for input length n
          + tossing r coins
          + Based on BPP alg, design a grid
              * Along Y axis, all possible n-bit input permutations
              * Along X axis, all possible r-bit coin toss permutations
              * looking for an r-bit perm that results in true for all possibl en-bit inputs
                  - If this combo of input and random is wrong, 1.
                  - For any input i, the BPP makes a mistake at most 1/2<sup>n+1</sup>, so there are at most 2<sup>r</sup>/2<sub>n+1</sub> 1s in any row (indicating mistakes)

---

<h3>Negligible functions</h3>

  * __D2.5__

---

<h3>One-way functions</h3>

  * __D2.6__
  * Computable in poly time
      - runtime is poly in the input length
  * s

<h3>one-way permutations</h3>

  * f: one-way function
  * f: permutation
      - input and output len the same, no two inputs map to the same output.
          + f:{0, 1}<sup>n</sup> &rarr; {0, 1}<sup>n</sup>s

---

<h3>Hardcore bits</h3>

  * __D2.7__
  * Computing a hardcore bit should be just as hard as inverting the function it comes from
  * binding property of commitment: send a locker with a lock
      - you don't send the key yet, but
  * Hiding property: protecting sender from receiver understanding output
  * Then you send your coin toss, then do the xor join.
  * Committment: digital analog of locker
  * Commit, decommit?