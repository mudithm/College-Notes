<h1>Lecture 10</h1>

---

Code from last lecture:

```c++
class Shape{
    void move(double xnew, doule ynew);
    virtual void draw() const; // Draw should be included, just in case.
    double m_x;
    double m_y;
};

class Circle : public Shape { // definition of a derived class
    virtual void draw() const; // overrides Shape::draw function
    double m_r;
};

class Rectangle : public Shape { // definition of derived class
    virtual void draw() const; // overrides Shape::draw function
    double m_dx;
    doble m_dy;
};

int main(){
    Shape* pic[100];
    pic[0] = new Circle;
    pic[1] = new Rectangle;
    pic[2] = new Circle;
    /// stuff
    for(int i = 0; i < 3/* or something else */; i++)
        pic[i]->draw();
 }

void f(Shape& s){
    s.move(10, 20);
    s.draw();
}

void Shape::move(double xnew, double ynew){
    m_x = xnew;
    m_y = ynew;
}

void Shape::draw(){
    // Draw some shape centered at m_x, m_y
}

void Circle::draw() const{
    // Draw a circle centered at m_x, m_y with radius m_r
}

void Rectangle::draw() const{
    // Draw a rectangle
}

```

__Keywords:__
  * "heterogeneous collection" -- collection of objects of different types
  * "strongly-typed languages" -- languages with strong emphasis on object types
  * "inheritance" -- inheriting type properties from a base class
  * "compile-time binding" -- static binding
  * "runtime binding" -- dynamic binding

Derived* ==> Base*

Derived& ==> Base&

The `virtual` keyword indicates to the compiler that the function in question should be subject to runtime binding. This should be used when overriding a base class function, because otherwitse the comiler will decide at compile time which function to use, and often will choose incorrectly. This is because the compiler will decide which function to use based on the type of the object.

>NEVER override a non virtual function

---

Say we now want to add a new shape that is a warning symbol. This class needs a different implementation of the move function, so it must be changed to `virtual`.

```c++
class WarningSymbol : public Shape{
    // .....
    virtual void move(double xnew, ynew);
    //...
};

void WarningSymbol::move(double xnew, ynew){
    Shape::move(xnew, ynew); // calls the base class's function
    // Flash 3 times
}

```

---

Updating the Rectangle class:

```c++
// ......
virtual void diag() const;
// .....
void diag() const{
    return sqrt(m_dx * m_dx + m_dy * m_dy);
}

```

In this case, we have to decide whether or not to make the function virtual. At first glance, we might not need to add it, since this applies to all rectangles. However, if we want to add a derived class `Square` into the mix, there is a more efficient way to implement `diag()`. Because of this, we make it virtual, just in case we decide to implement square.

---

__The Virtual Table (`vtbl`)__

C++ creates a virtual table whenever a function with the virtual tag is in the program. This assigns a number to each virtual function of a class, and this number is used to identify it when deciding which function to use at runtime.

Functions that are overridden in a derived class are assigned the same number as the function in the base class

EG if `draw` in the shape class has index 1, the rectangle's `draw` is at position 1 and circle's `draw` function has position 1.

A pointer to each class-specific table is added by the compiler as a data member of the class/derived class.

---

The `Shape` class includes a draw function, but shouldn't really draw anything.

To solve this, we define it as a "pure virtual function" as following:

```c++
class Shape{
// ......
virtual void draw() const = 0;  // syntax to creata a pure 
                                // virtual function
// ......
}

```

If a class has at least 1 pure virtual function, it is an _abstract class_. 
This means you cannot create any objects that are only of that type (you can still create its derived classes).  

By the way classes and inheritance works, it turns out that most base classes are abstract.

---

Back to the circle class:

```c++
class Shape{
    public:
        Shape(double x, double y);
    private:
        double m_x;
        double m_y;
};

class Circle : public Shape{
    // ...
    
    double m_r;
}


Shape::Shape(double x, double y) : m_x(x), m_y(y) {}

Circle::Cirle(double r, double x, double y) : Shape(x, y), m_r(r) {

}

```

>Remember, m_x and m_y are private variable of the Shape class, so they can't be directly assigned by Circle

Remember that mystery step to construction and destruction? We'll look into that now.

Construction:

1. Construct the Base part (if it exists)
2. Construct the Data members
3. Execute the body of the constructor

Destruction:

1. Execute the body of the destructor
2. Destroy the data members
3. Destroy the base part


---


Next Lecture -- virtual destructors

If a class is designed to be a base class, the destructor should be declared as virtual.