<h1>Lecture 7</h1>

---

<h5>Software evolution</h5>

  * Types
  * Language evolution
      - Successful languages evolve
          + BASIC (Developed for GE-225) (1962)
              * 40 microseconds to add
              * 500 microseconds to divide
              * ~40 KiB RAM
              * supported 20 users
                  - How did they split these few resources between ~40 KiB?
                      + short identifiers(2 letters; if more, only look at first 2)
                      + dollar sign at the end of string identifiers
                      + timeshared, meaning that only one program running at a time, results stored in storage, etc
              * Interactive
          + PDP-11 (1975)  
              * 4 microseconds to add
              * ~16 KiB RAM
              * 1.2 microseconds memory cycle
              * C, Unix developed on this machine
          + Today's CPU
              * 1 ns add
              * 100 ns memory access

---

<h5>Java</h5>

  * Java Design goals (original model):
      - "write once, run everywhere"
      - really portable compared to C programs
          + `short`: 16 bit
          + `int`: 32 bit
          + `long`: 64 bit
          + ON ALL MACHINES
      - Interpreter model for implementation
          + `javac` -- java compiler
          + `javac` Foo.java -> Foo.class
              * Foo.class is suitable for interpretation by an interpreter
              * consists of byte codes that run in the JVM, an abstract machine that has a stack
              * This code is passed to the Java interpreter `java` (written in C + assembly)
              * `java.c`
              * More reliable than the "disaster" of `C++`

```c
    main () {
        char *jp;
        switch (*jp++){
            case PLUS:
                a = pop();
                b = pop();
                // do plus operation
            ...
            case SUBSCRIPT:
                a = pop()
                b = pop()
                // do subscript checking, since the interpreter is slow 
                // already, might as well add checking
        }
    }

    // How java.c represents longs (for 32 bit systems)
    struct integer {
        long lo, hi; // each are 32 bits
    }

```
---

<h5>Compilers vs Interpreters</h5>

  * Compilers translate from source code to machine code
      - machine code runs directly on the machine
      - C, Fortran, Ada
      - Advantages:
          + performance (run-time)
  * Interpreters translate 
      - translate from the source to a high-level intermediate form
          + could be a tree
      - interpreter runs the intermediate form directly
          + interpreter is written in machine code, but is only used by the high-level form's calls
      - Advantages:
          + reliability/safety (possible in compiler code, but usually not worth it)
          + portability
          + debugability
          + easier to write

<h5>JIT (Just in time) Compiling</h5>

  * Typically, you want performance for the most computationally expensive parts of the program, and debugability, etc for the rest.
  * Hot-Spot Compiling:
      - while you interpret the program, keep a count of how many times each instruction is executing (profiling)
      - Results in a table, indexed by bytecode offsets
          + The bytecode ranges with the highest counts will be translated into machine code (compiled)
              * change the first bytecode in the range to go to some compiled machine code, then have the machine code go back to the byte code after doing the expensive computation

<img src="https://cdn.discordapp.com/attachments/581226308672159747/635959760218226709/20191021_145541.jpg" alt="New Java model" style="display: block; width: 80%; margin-right: auto; margin-left: auto"/>

---

<h5>Dynamic Linking</h5>

  * self-modifying code
  * Dynamic linker runs in code, and fetches/loads libararies dynamically
      - not all includes are present at compile-time
  * Downsides:
      - hard to debug
      - bug prone
      - security issues
  * The new Java interpreter is also an example of self-modifying code

---

<h5>Types</h5>

  * A type is: 
      - a set of values and 
      - a set of operations
  * primitive vs constructed types
      - primitives: provided by the language (ie `int`, `char`, etc)
      - defined by the user, out of primitives, using type constructors (ie `struct`)
      - Portability issues:
          + `float` can mean IEEE 754 floating point (`32 bit`)
  * Uses of types
      - annotations
          + useful for the reader of code
          + useful for the compiler
              * generate more efficient code
          + C++/Java are good at this
      - Inference   
          + figure out types of subexpression (ie `a+b*c`)
          + OCaml is good at this
          + more generic code
      - type-checking
          + redundancy to catch dumb mistakes
          + higher reliability
          + static vs dynamic type-checking
              * static: used in languages that aim for more reliability
                  - compile time
                  - eliminate need for type error checking for runtime
              * dynamic: more flexible
                  - static checks are too conservative
                  - static sometimes reject programs that are perfectly fine
          + Strongly typed: you cannot subvert the type system
              * weakly typed: C++; you can cast, etc
              * strongly typed: Java; runtime checks when you cast (can't cast to an incompatible type)

---

<h5>Abstract vs Exposed types</h5>

  * Abstract:
      - only operations are visibile
      - Cannot look at the internal representation
  * Exposed types:
      - operations on the types, and you can look at the implementation of the types
      - ie complex numbers  
```c
typedef struct {
    double re, im;
} cplx;

typedef struct {
    double rho, theta;
} cplx;
// This renaming can cause issues for any functions that relied on the previous def of cplx.

```
  * There's a grey area in between Abstract and Exposed
      - `float` x86-64:
          + 32-bit IEEE floating point
          + 1-bit sign, 8-bit exp, 23-bit fraction
          + for `0 < exp < 255`,
              * `+/- 2^e-127 * 1.fraction`
          + for `exp = 0`
              * `+/- 2^e-126 * 0.fraction`
          + for `exp = 255`, `f = 0`
              * infinity
          + for `exp = 255`, `f != 0`
              * `NaN` 
      - This started out as an exposed type, but it's not really anymore
          + there are many different floating point representations