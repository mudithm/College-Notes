<h1>Lecture 6</h1>

---

Initialization is not the same thing as assignment.

```c++
String s1;           // Initialization (using the default constructor)
String s2("Hello");  // Initialization (using the constructor that takes
                     //     a const char*)
String s3(s2);       // Initialization (using the copy constructor)

String s4 = s3;      // ??? Is this initialization or assignment?

s1 = s2;             // Assignment
```

The operation performed on `String s4` is simply initialization, using the copy constructor. The statememnt is the equivalent to calling the consctor with the right side as the argument. 

```c++
String s1;           // Initialization (using the default constructor)
String s2("Hello");  // Initialization (using the constructor that takes
                     //     a const char*)
String s3(s2);       // Initialization (using the copy constructor)

String s4 = s3;      // Initialization (using the copy constructor)
String s5 = "Hello"; // Initialization (using the const char* constructor)
                     // [effectively]

s1 = s2;             // Assignment
```

Aliasing -- when two functions / actions are performed on the same object or two things point to the same object.


In our String class, we know that there might be aliasing situations, but there it is expected and easily handled.

A less obvious scenario in which aliasing can cause issues is with non-member functions, like the following:


```c++
void transfer(Account& from, Account& to, double amt){
    if (from.balance() >= amt){
        from.debit(amt);
        to.credit(amt);
    }
}
```

This code would execute correctly, but could be problematic if the debit or credit functions incur surcharges or some other consequences. A transfer from one account to the same should realistically not be considered a transaction.

To fix this:

```c++
void transfer(Account& from, Account& to, double amt){
    if (&from != &to){
        if (from.balance() >= amt){
            from.debit(amt);
            to.credit(amt);
        }    
    }
}
```

And if we want to include a check for large transactions, we modify the code in the following way:

```c++
void transfer(Account& from, Account& to, double amt){
    if (&from != &to){
        if (from.balance() >= amt){
            from.debit(amt);
            to.credit(amt);
            if (amt > 10000)
                fileForm();
        }    
    }
}
```

---

<h4>Data Structures</h4>

1. Fixed-size array
2. Dynamically Allocated fixed-size array
3. Resizeable Array

But how can we implement a resizeable array?
Here is a possibility:


```c++
struct Node{
    int     data;
    Node*   next;
}

Node* head;

while (head != nullptr){
    cout << head->data << endl; 
    head = head->next;
}
```
This code displays all the numbers in the array, but in the process of reading through them, we lose access to them.

Another way:


```c++
struct Node{
    int     data;
    Node*   next;
}

Node* head;

for (Node* p = head; p != nullptr; p = p->next)
    cout << p->data << endl;
```

This code works a little better. 
