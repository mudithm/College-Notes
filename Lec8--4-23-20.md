<h1>Lecture 8</h1>

---

<h3>Agenda</h3>

  * Prelims: Zoom security, Quiz, working on logistics of Midterm 1
  * Continue Equivalence of Models: regular Expression direct to NFA

---

<h3>Regular Expressions to NFA</h3>

  * __F8.1__
  * Three most basic reg exs to create NFAs for are 
      - single symbol (ie  a)
      - empty string &epsilon;
      - empty set &empty;
  * Rules 
      - no &delta; transition TO the initial state
      - no &delta; transition FROM the accepting state
      - only one accepting state
  * Other operators
      - Union &xcup;
          + Replace accepting states with normal states
          + Add a new initial state that heads to both inits with &epsilon; transition
          + Add a new accepting state and have the old accepting states transition to this on &epsilon;
      - Concatenation &sdot;
          + make earlier accepting states normal
              * add an &epsilon; transition to the next initial state
          + keep final accepting state
      - Kleene star *
          + make the accepting state a normal state
              * Add an &epsilon; transition to a new accepting state
          + Add a new initial state with two new transitions
              * one on &epsilon; to the original initial state
              * one on &epsilon; to the accepting state
          + add a final looping transition from the old accepting state to the old initial state, on &epsilon;

---

<h3>Family of Languages</h3>
  
  * Any set of languages
      - Intuition &rArr; all lanaguges in the family have something in common
  * Suppose we have a family of languages, F. Suppose for any lanuages L<sub>1</sub> and L<sub>2</sub> in F that
      - L<sub>1</sub> (OP) L<sub>2</sub> is always also in F
  * Then we say that the family F is "closed" under that operation ("closed under (OP)")
  * These operations are also called closure properties

<h3>Closure property of Intersection</h3>

  * Given alphabet &Sigma; let L<sub>1</sub> and L<sub>2</sub> be FSL's
  * Claim: L<sub>1</sub> &xcap; L<sub>2</sub> is also a FSL
  * L<sub>1</sub> tells us &exist; DFA M<sub>1</sub> = (Q, &Sigma;, &delta;<sub>1</sub>, q<sub>1</sub>, F<sub>1</sub>)
  * L<sub>2</sub> tells us &exist; DFA M<sub>2</sub> = (Q, &Sigma;, &delta;<sub>2</sub>, q<sub>2</sub>, F<sub>2</sub>)
  * L<sub>1</sub> &xcap; L<sub>2</sub> should be all strings accepted by BOTH.
    - Construct DFA __F8.2__
    - The states of the new DFA N have to keep track of the states of the original two machines
      + The string must be accepted by both strings; ie, at least one of the machines will end up in a non-accepting state for some input that isn't accepted
  * Side note: another closure property is that set complementation is also a closure property  
    - If L is FSL, <div style="display: inline; text-decoration: overline;">L</div> is also an FSL

---

<h3>Closure Properties</h3>

| Family | &xcup; | &sdot; | * | &Sigma; | &xcap; | L<sup>R</sup> | 
| --- | --- | --- | --- | --- | --- | --- | 
| FSL | &check; | &check; | &check; | &check; | &check; | &check; |
| CFL | &check; | &check; | &check; | &#10006; | &#10006; | &check; | 

>Note: L<sup>R</sup> is the reversal of the langauge, and an &#10006; means that the FAMILY does not have this closure property, though individual languages within might. Also, every FSL is an easy CFL, FSL &sube; CFL