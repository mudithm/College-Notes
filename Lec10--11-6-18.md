<h1>Lecture 1</h1>

---

<h4>Reversing a list in Prolog</h4>

```Prolog
reverse ([], []),
reverse ([X|L],R):-
    reverse(L,_|),
    append(_|,[X],R)
```

This is an O(N^2) Algorithm, since the append operation is O(N) and it is done up to N times

A better solution is to use an accumulator:

```Prolog
% revapp (L, A, R)
revapp ([], A, A)
revapp ([X|L],A,R):-
    revapp(L,[X|A],R),


reverse(L,R):-
    revapp(L,[],R)
```

The first method, called "Naive Reverse," is a common Prolog benchmark, measured in "Logical Inferences per Second," or LIPS. (One Logical Inference is matching a subgoal to a clause head)

---


Another example: `member`

```Prolog
member(X,[X|_])
member(X,[_|L]):-member(X,L).

...

?-member(3,L)
L-[3,_27];
    X1=3,L1=[_96,_28]
        member(3, [_96|_28])
        _96 = 3
L=[_26, 3|_28];
L=[_7,_51,3|_92]



```


![Member and Append Trickiness](https://cdn.discordapp.com/attachments/581226308672159747/641766641247715348/20191106_143030.jpg) 

---

<h4>Debugging Prolog</h4>

  * use `write`, etc
  * use `trace` (`?-trace`)
      - Default output is very voluminous (lots of port traversals)
  * Debugger Model: 4 Port Model
      - `call` 
      - `succeed` 
      - `backtack` 
      - `fail` 
  * Note: the standard model for debuggin is 2-port, with `call` and `return` 

![Prolog Debugging](https://cdn.discordapp.com/attachments/581226308672159747/641767647083495434/20191106_143520.jpg) 

---

<h4>Memory Management</h4>

  * Prolog has an internal stack
      - successes grow the stack
      - failures shrink the stack
      - If there are lots of successes, it will garbage collect the stack

---

<h4>Unification in Prolog</h4>

  * matching by substituting values for variables
  * "binding" variables to values

```Prolog
member(X, [X|_])

?-member(Y,L)

A unifier for the above two terms: 
{Y=X, L=[Y|_29]}
Applying a unifier makes the two clauses the same
```

  * Superficially, we might think that this is similar to the `match` keyword in OCaml. However, in OCaml, pattern matching only wrks in one direction
      - In OCaml, we change the pattern to match the value
      - in Prolog, we can change both so that they are equal

![Matching and unifiers](https://cdn.discordapp.com/attachments/581226308672159747/641770330473627658/20191106_144556.jpg) 

```ocaml
match e with 
    | [] -> ...
    | h::t -> ...
```

is equivalent to 

```Prolog
?-m(E)
m([]):-....
m([H|T]):-...
```

---

<h4>More matching</h4>

  * Since both directions can match simultaneously,
      - `p(f(x), y)` 
      - `?-p(A, g(B))` 
      - binds to 
          + `A=f(_96)`
          + equivalent to `p(f(x), g(B))` 
      - `q(f(X), X)` 
      - `?-q(A, g(B))` 
      - binds to
          + `A=f(g(B))` 
          + equivalent to `q(f(g(B)), g(B))` 

---

<h5>Problems with Unification</h5>

  * can create a binding loop
      - `e(X,X)`
      - `?-e(Z, f(Z))` 
      - binds to 
          + `Z=f(f(f(.....` 
  * Can also create logic that doesn't make sense from a mathematical perspective
      - Peano Arithmetic: natural numbers, +, x, -, forall, thereexists, logic

```Prolog
zero 0
succ(E) E+1

?-add(succ(succ(zero)), succ(succ(zero)), R)
add(zero, N, N),
add(succ(N), M, succ(MplusN)):-add(M,N,MplusN),
sub(A,B,BminusA):-add(A, BminusA, B) % this will work as long as B > A
lt(N, succ(N)),
lt(M, succ(N)):-lt(M, N)

?-lt(H,H)
H=succ(H)
% actually, would be H=succ(succ(succ(...)))
% This is not logical, since it could say that infinity is less than infinity..
```

'Solution' (sort of): `unify_with_occurs_check/2`
But this is slow. So, practically, just write your code in a way that doesn't allow them.

---

<h5>Pruning Possible Solutions</h5>

  * The possible solutions in Prolog are in a tree
  * It is possible that, after traversing one of the branches of the tree, you find that another subtree cannot possibly be true
      - in this case, you can remove this subtree from the possible solutions
          + this is an imperative process, not a logical one, but it can make computation faster
  * When would you to this?

```Prolog
% if generator(X,Y,Z), tester(X,Y,Z) is only true when Z is a member of Z,
% adding an additional call may make computation faster.

generator(X,Y,Z), tester(X,Y,Z)
% becomes
generator(X,Y,Z), member(X,Z), tester(X,Y,Z)

```

  * This approach also has issues--for example, there is no check to ensure that member is not true multiple times.
      - the alternatives should be cut off if the base case succeeds

```Prolog
    memberchk(X,[X|_])
    memberchk(X,[_|L])
    memberchk(X,L)

    generator(X,Y,Z), memberchk(X,Z), tester(X,Y,Z)
```

  * `mebmerchk` uses `cut`
  * If you backtrack into a `cut`, it fails and its caller fails.
      - So, after it succeeds once, it can never backtrack to it again, and so none of the subtree of that check will be computed.

Example implementation:

```Prolog
once(P):-P,!.
memberchk(X,L):-once(member(X,L)).

% New primitives:
\+(P)   :-  P,!,fail    % acts like a logical negation. alias 'not'
                        % a more accurate is "not provable"
\+(_).
```

---

<h5>Closed World Assumption</h5>

  * If I don't tell you something about a predicate, then it is false