<h1>Lecture 1</h1>
*Intro to Database Systems*

---

<h3>Contact info</h3>

  * Email: [rrosario@cs.ucla.edu](rrosario@cs.ucla.edu)
  * Office Hours: Monday/Wednesday 6-7pm
      - Link: [https://ucla.zoom.us/my/ryanrosario](https://ucla.zoom.us/my/ryanrosario)
  * TA tbd (My section has no TA lol)

<h3>Grades</h3>

  * Sliding Scale
      - Expectation: Average will be B, B-

<h3>Assignments</h3>

  * There will be homework assignments and mini-projects
      - Emphasis on mini
  * Read the directions carefully about how to submit your work as it may vary depending on the format of the assignment
  * Homework will be submitted on CCLE
      - A mixture of conceptual questions fromt he book or myself
      - will focus on SQL with some implementation exercises in Python and Spark
      - These should be considered exam prep
      - For SQL exercises, you wil work with real data, with interesting datasets
  * 5-6 assignments, with the lowest one dropped

<h3>Exams</h3>

  * Midterm: likely open notes, 100 points, 
      - multiple choice, free response coding, short essays
  * Final: cumulative and comprehensive, beginning at the designated final time and date, usually 150-200 points, will be open notes (at least)

<h3>Projects</h3>

  * A much abbreviated version of the different projects will be assigned

<h3>Late work</h3>

  * you have 6 grace period days for the assignments
      - You can use these days for any submission
      - 1 hour late = 1 day late
      - Any additional days late will result in half credit or no credit at all
      - THIS DOES NOT APPLY TO THE TAKE HOME EXAMS

---

<h3>Textbooks</h3>

  * *Database System Concepts*, Silbershatz et al
  * *Designing Data-Intensive Applications*, free from Safari Books [here](https://proquest.safaribooksonline.com/)
  * *Database Internals*, also at Safari books [here](https://proquest.safaribooksonline.com/)
  * Readings will be assigned every week
  * NOTE: some of these books use specific SQL implementations, but we will be using ANSI SQL

---

The rest of the notes are [here](https://drive.google.com/file/d/1icjkb-CxPmb4NFhTehfk8c_-fLT6IDgd/view)

---

<h3>Lecture</h3>

<h3>Way back when...</h3>

  * Data as stored in flat files within a system's filesystem
  * UCLA student records were stored in flat files as well, until the last 10 years or so
  * System administrators had to manually write individual apps to add/update/delete records from these flat files. For ex:
      - Adding new students and instructors
      - Generating class rosters
      - Computing GPA's
      - A bunch of other stuff
  * Drawbacks of this approach: 
      - Data integrity and redundancy
          + Multiple people touch these files and applications
              * they may choose to use different structures or slightly different formats that mess everything up
          + Duplicated data
              * Each grade report, roster, and registration record contains the same student and course information over and over
          + Add'ly, there are higher storage costs, and it is possible for duplicated data to not agree (data corruption, etc.)
      - Sysadmin bottleneck
          + Each time someone retrieve a new type of data or report, the sysadmin must write a new program
          + Change prereqs fore a course? new application = wait
          + Decide to collect new information abt students or courses? new application = wait
      - Integrity
          + There are many constraints at UCLA: enrollment restrictions, major requirements, etc and the system must enforce these constraints. This requires adding new logic to applciations, and is difficult when multiple files are invovled
      - Lack of Atomicity
          + If the system fails during a high-stakes operation
              * EG bank transaction: if we transfer money from A to B and the system dies after withdrawing the money from A, A and B will be very unhappy
          + Enrollment: suppose the `Exchange one class for another` function drops a class and then adds a class. If this action is not atomic, then you might drop a class without adding the other and be short on units.
          + We need a way to recover and fall back -- either do it all successfully, or do nothing
          + More sophisticated journaled filesystems (like Apple HFS+ or ReiserFS) record changes to files that make this easier, but at the time these did not exist
      - Concurrent accesses
          + Concurrent accesses can cause inconsistent data
          + Enrollment ex: if two students add a class at the same time, myUCLA might update both only once and get the wrong student count
  * UCLA IT used this the hard way
      - DB2 was introduced as the database for certain student records
          + Now owned by IBM
      - It was found that many of the student records were corrupted
          + Luckily, they were able to recover the data because there was a lot of redundancy
      - DB2 is an Online Transaction Processor, that is, it is optimized for online use and not batch use. So, batch requests/queries caused the system to grind to a halt
      - Now, we use Sql server, which along with other data warehousing programs allows UCLA to go almost entirely online.

<h3>There must be a better way!</h3>

<h3 style="text-decoration: none; color: red">&emsp;&emsp;DATABASES</h2>

<h3>Databases where we least expect them: Blockchain</h3>

  * Databases come in many forms, some of them surprising
  * Blockchain is similar to a distributed database, with one major difference
  * With centralized databases, admins have all the power
      - They can access/modify data, violate privacy, etc
  * With blockchain, each participant maintains their own data and updates to the database. All nodes in the system cooperate to make sure the database comes to the same conclusion -- a form of security

<h3>Databases where we least expect them: <code>git</code></h3>

  * Git is described as a "stupid content tracker"
  * It can track any kind of content, and can theoretically be used to create a NoSQL database
  * It is a `content-addressable filesystem`, which is a fancy way of saying that it is a `key-value store`.
  * Both Git and Blockchain use `merkle trees` as their underlying data structures, but Git is not a Blockchain. More info [here](https://hackernoon.com/merkle-trees-181cb4bc30b4)
