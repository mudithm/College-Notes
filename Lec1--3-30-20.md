<h1>Lecture 1</h1>
*Intro Lecture for Cryptography*

---

<h4>Class Format</h4>

  * Homework will be optional, posted online
  * Midterm and final will be take home, 24 hours
  * Office Hours:
      - Monday, 4-5pm PST
      - If no one shows up in the first 10 minutes, prof. will just disconnect
  * [Notes](http://web.cs.ucla.edu/~rafail/PUBLIC/OstrovskyDraftLecNotes2010.pdf)

---

<h4>Overview of the Course</h4>

  * What are the hardness assumptions?
  * What does it mean that you cannot break it?
  * Theory of Cryptography, based on One-way Functions
  * Pseudo-random generators/functions/permutations
  * Trapdoor permutations, public-key encryption, homomorphic encryption
  * Private information retrieval
  * Two-party/multi party authentication

<h4>Basics</h4> 

  * What is a secret?
      - It used to be that a secret is some kind of encryption scheme that is use to encrypt information -- but if the adversary gets ahold of the encryption scheme, your code is broken
          + Classical example: write message on bald head, shave to get the information. Obv, if you don't know that this is the way of comms, it's probably secure, but once the adversary finds out, they can easily get the information
      - We are looking for `Provable Security` 
  * Influential Papers:
      - Diffie-Hellman, 1976 -- `Public Key Encryption` 
          + introduced the concepts
      - Blum, Micali, Yao -- `Pseudo-random Generators` 
      - Goldwasser and Micali -- `Probabilistic Encryption` 

---

<h4>Pseudo-random Generator</h4>

  * Function that takes in a huge (ie 1000 bits) input and outputs a deterministically generated random-looking string (ie 10 MB)
  * Provable security -- no one can tell whether these 10 MB of bits have been flipped randomly by you or by some deterministic process
  * __F1.1__

---

<h4>P vs NP</h4>

  * Polynomial-time algorithms and Non-deterministic polynomial-time algorithms
  * __F1.2__
  * It is unclear to people outside of cryptography for something to be provably secure
  * Blum/Micali paper: notion of a reduction
      - If you can solve A using a B as a subroutine, then A is no harder than B.
      - This tells us that the concept of cryptography (and Pseudo-random generators) are pointless if P = NP, because then the pseudo-random generator function's output would be no harder to compute than the input.
          + NP: Does there exist an algorithm that determines whether there is a short seed for this equation?
              * For any polynomial-time machine, it is impossible to distinguish whether each individual bit was flipped in the output or it was deterministically generated by some seed (if a PSG is designed properly)
  * How do we prove that this is the case? __F1.3__
    - The crypto object (ie PSG) is as secure as the famous open problem in math (Discrete Log Problem)
      + Notion of reduction that is used in cryptography all over the place
      + If you broke the crypto object, then there is an efficient algorithm that solves the Discrete Math Problem
        * Basicallly, they don't know how to prove that the crypto obj is secure, but they were able to show that it is as secure as another algorithm, by showing that:
          - If you are able to crack the crypto primitive, you can solve this unsolved and complex math problem
          - This is a general strategem for proving 
            + Take some famous unsolved problem in mathematics
            + Prove that, if someone breaks the security guarantees of the crypto obj, they can solve the problem
  * __F1.4__ Multiplication and Factoring (RSA)
    - RSA is as secure as factoring -- it is more complicated, but if factoring is solved, then RSA can be broken
      + Shor's algorithm proves that multiplication is not a one-way function becase factoring is easy in quantum computing
      + Despite this, RSA is still super commonly used for many online transactions
      + This is because it is still exponentially expensive to add bits to quantum computers (right now, google has maybe 70-bit factoring figured out, but increasing the complexity is difficult)
    - __F1.5__ One-way functions
      + One-way function assumption: given f(x), it is very difficult to determine x. (easy to compute, hard to invert)
    - This also introduces the concepts of Classically difficult problems and Quantum difficult problems

---

<h4>Straight Math vs Crypto</h4>

  * In math, "easy" problems can be done in poly-time
  * In cryptography, the adversary can flip coins (has randomness)
    - So "easy" becomes `probabalistic poly-time` 
    - If you flip coins, you can always be lucky and guess the answer
    - The goal is to make this probability so low that it would be very unlikely for this to happen
    - `Probabalistic poly-time:` 
      + Algorithm can flip coins (has randomness)
      + There is some probability of success (of guessing the answer)
      + Running time can also be probabalistic
      + __F1.6__
        * This is expected polynomial time, because while there is a tiny chance (1/2<sup>n</sup>) that it will take 2<sup>n</sup> steps, in most cases it will take 2 steps
          - You can find the expected time kind of like expected value

---

<h4>Why do we care about randomized algorithms?</h4>

  * Given a number x, abs(x)=n, is it prime?
  * Randomized alg (Rabin-Miller)
    - O(n) expected
    - Deterministic primality testing
      + Best known alg: O(n<sup>6</sup>) with randomization
      + O(n<sup>11</sup>) reduced to this
  * Amplification of a randomized algorithm
    - __F1.7__
      + Doing this can greatly improve the efficiency of the algorithm

---

<h4>Modular Arithmetic in Z<sub>p</sub></h4>

  * Z: Set of integers
  * p is an element of Z
  * Z<sub>p</sub>: `{0, 1, ..., p-1}` 
    - Addition: wraps around (result is mod by p)
    - Multiplication: same story (result is mod by p)
  * Equivalence class: [0]<sub>p</sub> is the set of all integers that are equivalent to 0 in the space Z<sub>p</sub>
    - ie [0]<sub>3</sub> = `{0, 3, 6, 9, ...}` in the set Z<sub>3</sub>