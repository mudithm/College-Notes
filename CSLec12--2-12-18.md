<h1>Lecture 12</h1>
<h5>More Recursion</h5>

---

Sorting Algorithm from last lecture:

```c++

sort(/*some unstorted list*/){
    if (list.size() >= 2){
        // Split the pile approx evenly into two unsorted subpiles
        sort(the left unsorted subpile);
        sort(the right unsorted subpile);
        // merge the two sorted subpiles
    }


}
```

Translating the Pseudocode:

```c++

void sort(int arr[], int size){
    if (size >= 2){
        // Split the pile approx evenly into two unsorted subpiles
        int subDiv = size / 2;
        int arr1[subDiv];
        int arr2[size - subDiv];

        for (int i = 0; i < subDiv; i++)
            arr1[i] = arr[i];
        for (int j = subDiv, k = 0; j < size; j++, k++)
            arr2[k] = arr[j];     

        // sort the left unsourted subpile
        sort(arr1, subDiv);

        // sort the right unsorted subpile
        sort(arr2, (size - subDiv));

        //merge the two sorted subpiles
        for (int m = 0, i = 0, j = 0; m < size; m++){
            // check if one of the piles is empty
            if ( i >= subDiv){
               for (; m < size; m++, j++)
                  arr[m] = arr2[j];
            }
            else if ( j >= (size - subDiv)){
               for (;m < size ; m++, i++)
                  arr[m] = arr1[i];
            }
            
            // else, find the smaller and add it to the array.
            else if (arr1[i] < arr2[j]){
                arr[m] = arr1[i];
                i++;
            }else{
                arr[m] = arr2[j];
                j++;
            }

        }          
    }

}

```


Another implementation that is more versatile (Professor's):

```c++
void sort(int a[], int b, int e){ // sort from a[b] through a[e-1]
    if (e - b >= 2){
        int mid = (b+e) / 2;
        sort(a, b, mid); // sort left half
        sort(a, mid, e); // sort right half
        merge (a, b, mid, e); // merge two halves
    }
}
```

---

An infinite loop can take some time to fill up memory and crash. An infinite recursion, however, will tear through memory pretty fast, because it is allocating new variables and memory for every iteration of the function in the runtime stack.

For this same reason, if you know that a function will use a lot of memory in each iteration, you might want to consider a non-recursive implementation.

When designing a recursive function, make sure that your inductive reasoning is solid--that you have sufficient base cases, that your algorithm approaches these base cases, and that there is no flaw in the logic of your induction.

---

The three general schemes for recursion:

1. Splitting the data in half (Divide and Conquer)
2. Splitting off the first element (the first and the rest)
3. Splitting off the last element (the last and the rest)

Examples:

```c++
//Divide and Conquer
// Inefficient, but functional
bool contains(const int a[], int size, int target){
    if (size <= 0)
        return false;
    if (a[0] == target) 
        return true;
    int a1[size/2], a2[size - size/2];
    
    // some code to get the approptiate values of a in each array



    if (contains(a1, size/2, target))
        return true;
    else if (contains(a2, size - size/2, target))
        return true;

    return false;

}

//First and the Rest
// still somewhat inefficient, but less so.
bool contains(const int a[], int size, int target){
    if (size <= 0)
        return false;
    if (a[0] == val)
        return true;
    return contains(a, size-1, target);
}

//Last and the Rest
// same as the prev
bool contains(const int a[], int size, int target){
    if (size <= 0)
        return false;
    if (a[size] == val)
        return true;
    return contains(a, size-1, target);
}
```

Remember to return the value of the contains function during recursion. A common error is to implement the function as the following:

```c++
bool contains(const int a[], int size, int target){
    if (size <= 0)
        return false;
    if (a[size] == val)
        return true;
    contains(a, size-1, target);
}
```

Since the recursion does not return a value, it will never output an answer unless the size is initially 0.

---

Writing a recursive function to solve the maze problem:

Pseudopseudocode
```c++
bool solve(start)
{
    if (start == goal)
        return true;
    mark this position as visited
    for each direction
    {
        if moving one step in that direction is possible, AND that spot has not been visited, then if (solve (position reached by moving that step))
            return trues;
    }
    return false;
}
```

A base case is a case in which no recursive calls are made. In this case, since if the for loop does not execute the recursive function is never called, the false condition of the for loop is a base case.

