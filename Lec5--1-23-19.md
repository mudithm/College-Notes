<h1>Lecture 5</h1>

---

<h4>Modularity and Proceseses</h4>

  * functions are bad at modularity
  * process modularity (hard modularity)
      - isolation among process
      - (we want to relax this)

<h4>How Processors Work</h4>

  * Registers (1 core)
      - potentially running other process
  * Primary Memory
  * I/O
      - typically at the OS level, kernel mode etc

<h4>Context Switching</h4>

  * Time intensive
      - Have to copy and restore from registers
      - have to switch process
  
<h4>Virtual Memory</h4>

  * Rather than using physical memory directly, virtualize it
  * The same address for different processess will map to different physical memory addresses
  * Stored in the  Page table

----


<h4>Back to POSIX primitives</h4>

  * `pid_t fork(void)` 
      - signed integer for all real processes
      - "clones" current process 
          + except for: 
              * %rax values (return values from fork)
                  - child gets 0, parent gets the child's pid
              * pid (new child pid is unique)
              * ppid (parent process id)
              * file descriptors
                  - A child process does not see the same fd as its parent
                  - file descriptions/meta info: some other information that doesnt directly deal with the file (eg offset on disk, etc)
                  - The file descriptor points to the description.
                  - Reads from different processses on teh same file can all alter the file description/metadata (ie offset) and thus result in different reads. 
              * execution time
              * pending signals
                  - ie child has no pending signals at fork
              * File locks
              * etc
          + The goal is to make the cloned process as close to the original as possible without causing trouble
          + no change to program, but change the number of processes
      - If your parent process dies, the OS reassigns your parent as process 1
      - If process 1 dies, idk what happens
      - The processes are stored in the process table.
          + if you Run fork in an infinite loop, it will eventually start failing
      - When a process dies, it exits and becomes a zombie. The parent process has to call waitpid to check whether or not the parent has become a zombie, and then kill it.
      - What happens to a child process if a parent creates a child, and then the parent exits and stays a zombie
      - To "disown" a child, fork twice
          + grandchild will do the action, the child will die, and the grandchild will be given to process 1, which will take care of any zombies.
  * `int execvp(char const *file, char* const *argv)` 
      - Change the program running, but no change to process
      - ALWAYS returns -1 (if it returns anything at all)
          + this means it failed
          + also sets errno

```c
pid_t p = fork();
if (p == 0)
{
    execvp("something")
    perrror (something)
}
else if (p < 0)
{

}
else 
{
    // this means this is the parent process
    // so we should wait
    //pid_t waitpid(pid_t proc_id, int* place_to_put_exit_stst, int option);
    if (waitpid(p, &status, 0) < 0)
        printf("ouch");
    else if (WEXITED(status) && WEXITSTATUS(status))
    {
        print ("date ok");
    }
    else
    {
        print("date failed");
    }
}

```

----

<h4>What if a process goes bad?</h4>

  * ie inf loop, etc
  * `kill` system call
  * `int kill(pid_t, int sig)` 
      - ie `kill(369, SIGKILL)` 
      - you can only do this to your own processes, unless you are root
  * Race condition:
      - `ps` shows  a process with 100% CPU utilization
      - kill -9 369
      - If the process dies before the kill signal is sent, and another process forks and returns 369, that innocent process will be killed

```c
pid_t p = fork();
if )(p == 0)
{
    // om child
        int fd = open("foo", O_RDONLY) // set a new file descriptor in the child proc
        // Yo can also use DIP
        // A lot of "setup" parameters that the parent can set for the child

    //
    execvp ("cat", etc);
    perror("some error pccured")    
}

```

> The section between within the if statement before the actual execution of the command is the interesting, but paingul, pat in which specific parameters are called for the child proess.
> 
> In other OSs, this process is replaced with a single system call, spawnp.


**Note: the `*restrict` keyword assumes that there is no overlap between parameters

```c
int posiz_spawnp(pid_t *restrict pid, char const* *restrict file, posizspawn_file_actions, const * filfe file_act, posizspawnattr_t *restrict atkjsadflkadslfkj etc)
```
This is mainly used because it is optimized in windows, whereas fork() runs very slowly.

A standard trick to make fork() go faster is to clone the page table rather than the entire memory. This can be done by making the page table contents read-only, and sharing it between the parent and the child. Copy-on-write is used to modify memory in this scenario (one process will cause a fault, when accessing a page from the page table. it will receive a copy of the page it wishes to modify, and the other process will be free to modify its version of that page as well.

Vfork() does this same thing, but shars the page table itself rather than copying it. THe parent is frozen until the child execs or exits to prevent race conditions.

---

<h4>Issues with fork, files, etc</h4>

  * `int fd = open("foo, O_RDWR); // takes fd` 
  * `unlink("foo"); // takes string` 
  * `read(fd, buf, sizeof buf); // takes fd`
  * The two types of input should interfere with eachother as little as possible.
  * The file lasts as long as any file descriptor is open to it.