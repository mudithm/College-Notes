<h1>Lecture 15</h1>
<h5>Pointers and Arrays, Continued</h5>

---


``` c++
    ... findFirstNegative(double a[], int n){
        for (double* dp = a; dp < a + n; dp++){
            if (*dp < 0)
                return dp -a;
        // remember, &a[i] - &a[j] ===> i - j. It does NOT return how many
        // bytes apart they are, but rather how many elements apart they are. 
        //(this can be negative) ++
    }
    return -1;
    }


    int main(){
        double da[5];
        /......
        double* fnp = findFirstNegative(da, 5);
        if (fnp ....)

    }

```


>_++ Note that if the pointers represent elements in different arrays, the resulting value will not make sense--subtraction of these pointers will result in the difference in there byte location in memory divided by 8._

For example:

Index: | 0 | 1 | 2 | 3 | ... | 0 | 1 | 2 
---|---|---|---|---|---|---|---|---
**x** | 145.0 | 254.0 | 334.0 |345.0 | **y** | 345.0 | 554.0 | 435.0
**Byte Location:** | 2000 | 2004 | 2008 | 2012 | ... |2056 |2060 | 2064 

    &x[2] - &y[0]  ===>  -6, because the values are 48 bytes apart. (does NOT 
        // return 2, as you might expect.)


>Remember that the compiler may choose to store arrays in a different order than they are initialized. the y array in the above example could instead begin at the memory location 1008, and the result of the calculation would be 1000.


> <p style="height: 1px;" > </p>

---


> <p style="height: 1px;" > </p>


For each pointer type, there is a specific bit pattern that represents a pointer that does not point to anything.

This value is the infamous `null pointer value`, and can be used for any pointer type.

On most computers, this value will be a pointer with all 0 bits.


> *In C++11 and later:  nullptr*

If you receive an error message containing a memory location `0x00000000`, that means your program tried to follow a null pointer.

>The only things you can really do with the null pointer value is set a pointer to its value (usually if something in your program is not working as expected) or compare it for equality (to see if a pointer is valid or not)

*The old way of referencing the null pointer was `NULL`. You may still see this in older code or in libraries.*


Another strange way to reference the null pointer is as follow: `type& point = 0;` 


> <p style="height: 1px;" > </p>


---


> <p style="height: 1px;" > </p>


<h5>Structures</h5>

Employee | Salary | Age
--- | --- | ---
Ricky | $50,000 | 45 
Lucy | $60,000 | 42
Fred | $55,000 | 60


> <p style="height: 1px;" > </p>

To store the data in the above table, it might seem like you shoud use a 2D array. The problem with this, however, is that each column is of a different type, which cannot be handled by normal arrays.

One possible way to store this would be by using three parallel arrays of different types.

Index: | 0 | 1 | 2  
---|---|---|---
Employee Name: `string empName [i]` | `"Ricky"` | `"Lucy"` | `"Fred"` 
Salary: `double salary [i]` | `50000` | `60000` | `55000`
Age: `int age [i]` | `45` | `42` | `60`


> <p style="height: 1px;" > </p>


Another more useful way is to do the following:

```c++
    // Using the "struct" type allows you to define your own type
    #include <iostream>
    #include <string>

    using namespace std;

    struct Employee{ 
        string name;     // These variables are called fields, instance 
        double salary;   // variables, attributes, etc. In C++, they 
        int age;         // are called "data members"

    };  //do NOT forget to end this declaration with a semicolon!

    void printPayCheck(Employee& e){
        cout << "Pay to the order of " << e.name << " the amout $" << e.salary/12 << endl;
    }

    int main(){
        // Declaring variables of custom types follow the typical 
        // initialization syntax.

        Employee e1;
        Employee e2;

        e1.name = "Fred";
        e1.salary = 50000;
        e1.age = 60;

        cout << "Enter a name:  ";
        getline(cin, e2.name);
        cout << "Enter a salary:  ";
        cin >> e2.salary;
        cout << "Enter an age:  ";
        cin >> e2.age;

        // These types can also be stored in arrays.

        Employee company[100];
        company[2] = e1;
        company[3] = e2;
        company[2].name = "Ricky";
        company[3].name = "Jeff";
    
        int nEmployees = 0;
        //...read in some info, fill array, set nEmployees ...

        printPayCheck(&company[2]);
        // Will output: Pay to the order of Ricky $5000
    }

```


> <p style="height: 1px;" > </p>


**At initialization:**

Variable | Name | Salary | Age  
---|---|---|---
`Employee e1;` | `"" ` (empty string) | `garbage value` | `garbage value`
`Employee e2;` | `""` (empty string) | `garbage value` | `garbage value`

> <p style="height: 1px;" > </p>

**After `e1.name = "Fred";` , `e1.salary = 50000`, and `e1.age = 60;`:**

Variable | Name | Salary | Age  
---|---|---|---
`Employee e1;` | `"Fred" `  | `50000` | `60`
`Employee e2;` | `""` (empty string) | `garbage value` | `garbage value`

> <p style="height: 1px;" > </p>

**After `getline(cin, e2.name);` , `cin >> e2.salary;`, and `cin >> e2.age;`:**

Variable | Name | Salary | Age  
---|---|---|---
`Employee e1;` | `"Fred" `  | `50000` | `60`
`Employee e2;` | `some input` | `some input` | `some input`



> <div style="height: 1px;" > </div>

---


> <p style="height: 1px;" > </p>
