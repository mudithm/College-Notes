<h1>Lecture 11</h1>

---

<h4>Processor Modes</h4>

  * Operating modes that place restrictions on the type of operations that can be performed by running processes
      - User mode: restricted access to system resources
      - Kernel/Supervisor mode: unrestricted access
  * System resources include
      - memory
      - I/O devices
      - CPU

---

<h4>User Mode vs Kernel Mode</h4>

  * Hardware contains a mode-bit, 0 is kernel, 1 is user
  * User Mode
      - CPU restricted to unprivileged instructions
  * Kernel Mode
      - Unrestricted CPU, can use all instructions, can access all of memory and take over the CPU anytime

<h4>Why dual-mode operation?</h4>

  * System resources are shared between processes
  * OS must ensure:
      - Protection
          + an incorrect/malicious program cannot affect other processes or the system as a whole
      - Fairness
          + Make sure processes have a fair use of devices and the CPU

---

<h4>How to achieve Protection and Performance</h4>

  * Goals:
      - I/O protection
          + Prevent illegal i/o ops
      - Memory Protection
          + Prevent processes from accessing illegal mem, modify kernel code and data structures
      - CPU Protection
          + prevent a process from using the CPU for too long
  * Instructions that might affect any of these goals are privileged and can only be run by trusted code

<h4>Which code is Trusted?</h4>

  * Only the kernel code is trusted
      - Kernel is core of the OS
      - Interface between h/w and s/w
      - It controls access to sys resources
          + implements protection mechanisms
          + cannot be changed through the actions of untrusted software in user space

---

<h4>System Calls</h4>  

  * List of functions in the kernel code that programs are able to call
  * They take care of the interaction with IO, managing memory, etc.
      - used to request a service from the kernel
      - changes CPU mode to kernel for the duration of its execution
      - Part of the kernel of the OS
      - Verifies that the user should be allowed to do the requested action and the does the action
      - This is the only way a user program can perform a privileged operation
  * During a system call, control is transferred fro the untrusted user process to the trusted OS
  * When a system call is made, the program is interrupted (SIGINT/trap) and control is passed to the kernel, If the operation is valid, the kernel performs it.
  * The process will hang until it receives that data from the kernel or an error message from the kernel.

---

<h4>System Call Overhead</h4>

  * System calls are expensive and can hurt performance
  * The system must do many things:
      - Process is interrupted and computer saves its state
      - OS takes control of CPU and verifies validity of op
      - OS performs requested actions
      - OS restores saved context, switches to user mode
      - OS gives control of the CPU back to user process

---

<h4>Library Functions</h4>

  * Functions that are part of the standard C library
  * To avoid a system call overhead we use equivalent library functions
      - getchar, putchar vs read, write (for standard I/O)
      - fopen, fclose vs open, close (for file I/O), etc
  * Why use library calls, when it adds another layer between the kernel and the user?

---

Presentation:

Quantum Mechanics Person
Low coherence time
Fragile
must be kept at very low temperature
Circuit Depth: Shor's factor
Possible that square root setup can apply to constant time operations

---

Image averaging facial recognition techniques

multiple images used together make it easier to identify someone (using facial recog tech)

Pie variation
    Pose
    illumination
    expression

Surveillance footage photos are usually low quality

Process: keep only core features of the face

Steps: 
1. Normalize (zoom as necessary, align the eyes, greyscale, crop everything but face)
2. Algorithms to generate Eigenfaces, which form a basis of a subspace that contains any of the images that were given