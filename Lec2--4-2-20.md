<h1>Lecture 2</h1>

---

<h3>Administrative Things</h3>

  * Office Hours
      - 7:30 - 8:30 AM Thursday mornings
      - After Thursday's lecture
  * Gradescope Entry Code: mggnxj


<h3>Def of Proof</h3>

  * A proof is a combination of mathematical notation and English that gives a convincing argument for that which you are trying to prove

---

<h3>Models of Computers, Computations, and Problems</h3>

  * `Alphabet` &#x2261; any non-empty finite set
      - its elements are "symbols"
          + except `&epsilon;` is not allowed as a symbol, for reasons described later
      - If you treat a set as an alphabet, the elements of that set are symbols, if they are the elements of the alphabet
  * `strings`/`words` &#x2261; finite sequence of symbols (concatenated together)
      - e.g., with alphabet &sum; = {0, 1}
      - Words: 0, 1, 00, 01, ...
          + This is an infinite set, but each element is a finite string
              * indefinitely long, not infinitely long
  * &sum;<sup>+</sup> &#x2261; {0, 1, 00, 01, ...}
      - Given a finite alphabet, putting a plus sign like above gives the set of all strings that can be constructed with the given alphabet
      - This is NOT the power set
  * `Concatenation`: represented by the symbol &sdot;
      - `11 = 1 &sdot; 1` 
      - `1&sdot;01=101=10&sdot;1` 
  * `Language over &sum;` &#x2261; set of words over alphabet &sum;
      - {00, 01, 10, 11}
      - {} -- The "empty language"
  *  Concatenation of Languages
      -  __F2.1__
      -  This operation is not necessarily commutative
          +  Order matters; the elements in the language that precedes the concat operator will be placed in front of elements from the other set 
      -  Note: concatenating with the emtpy set results in the empty set.   
      -  Concatenation of languages requires that both sets contain elements; otherwise, the resultant set will be empty.

---

<h3>More concatenation</h3>

  * __F2.2__
      - This is sort of analagous to multiplication, with the exception of commutative -- order matters.
  * Is there a "1" equivalent?
      - ie _&sdot;W = W = _&sdot;W
  * Yes; this is represented by &epsilon; &#x2261; the empty string
      -   &epsilon;&sdot;W = W =  &epsilon;&sdot;W
  * `Length of a word, w` &#x2261; the number of symbols of w
      - |w|
      - |aab|=3
  * &sum;<sup>*</sup> &#x2261; &sum;<sup>+</sup> &#8746; {&epsilon;}
  * Aside: __F2.3__
      - Concatenating with the empty set is analogous to "multiplying" by zero, and concatenating with the set of &epsilon; is analogous to "multiplying" by 1

---

<h3>Back to <b>F1.3</b> </h3>

  * If the initial state heads to an accepting state, then the automaton accepts the empty string; otherwise, it does not.
  * Each state has exactly one outgoing edge for each possible input symbol
      - This means that the automaton is "fully specified"
      - Additionally, there is no node with two input signal branches with the same value (for now, we would consdier such a situation as an error condition (kinda))
  * If we didn't want to accept the empty string, we could slightly modify the machine by adding another state for the initial state that is not accepting.

---

<h3>F2.4</h3>

  * For the purposes of this problem, you are not allowed to have leading zeroes in this currency, unless there are no dollars and only cents
      - additionally, if you have only cents you MUST include a leading zero
          + ie, $0.99, not $.99
  * It's important to write out a general diagram before doing the final thing
  * Principle: your solution should be written in such a way that the design of the solution should be readable by an outsider
      - you should also give coherent names
  * if at any point you read a symbol that tells you that the word is not in in the language, you can direct it to a rejecting state.
  * Additionally, if you receive any input after the second digit after the decimal place, you go to the rejecting state.
  * If the purpose of a rejecting state is such that no further inputs can change the word's status in the language, you can send all subsequent inputs back to the rejecting state.
      - This case is called a Dead State
  * Blocking 
      - If there is a transition in the diagram missing, and it is not a fully specified machine, you can treat it as though the computation ends there, no matter whether or not the state it came from was accepting, or if there is further input.


