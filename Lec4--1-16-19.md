<h1>Lecture 4</h1>

---

<h4>Abstractions and Modularity</h4>

  * interfaces and implementation
  * policy vs mechanism
      - Mechanism: traps
      - on x86, INT instruction
          + sysenter: in user mode, sets cpu registers to values set in protected mchine-specific registers and puts you in kernel mode
          + sysexit: in kernel mode, sets cpu registers from machine specific registes, etc. Restores rip from rdx and rsp from rcx
      - a bit slow, memory traffic
      - x86-64 Linux syscall convention:
          + rax: system call # (small integer)
          + rdi rsi rdk r0 r8 r9 contain args
          + destroys rcx and r11, puts the result into rax
              * result: 64-bit integer. non-neg usually success, neg usually failure (-4095 &lt x &lt 0)
              * -errno at the C level, tells the most recent failure of a system call
          + NOTE: sysexit is not the only way to return to user mode; this is we we do not simply say that rcx becomes rsp but rather that it is destroyed; other ways might not set rcx to the stack pointer.
          + Despite all these efficiency improvements, this is still not fast enough. To go faster, we use VDSO's.
  * measurements and maintaining (Ops staff)

---

<h4>VDSO's</h4>

  * Virtual Dynamically-linked Shared Object
  * with a .so file, shared instructions are loaded into RAM and made accessible to many programs.
  * For VDSO's, this is done with kernel instructions rather than those of an ordinary file.
      - Example: pid()
      - You stay in user mode, but execute code provided by the kernel.
      - Since you only need to see the instructions for some system calls, and you do not need to make explicit system calls,
      - These simpler functions are part of the kernel because they might have components that are machine specific.

|Computer Layer|instructions|
|---|---|
|Application|Ordinary instructions|
|Operating System Kernel|Ordinary and Privileged instructions|
|Hardware|Priveleged instructions|


Having even more layers can make this more efficient.

EG x86:
|Computer Layer|instructions|
|---|---|
|High Level User|some ordinary instructions|
|Low Level User|ordinary instructions|
|High Level Kernel|some priveleged instructions|
|Low Level Kernel|priveleged instructions|

---

<h4>Resources on a typical HW</h4>

  * ALU (full speed by all layers)
  * commonly used registers (full speed to all layers)
  * Priveleged registers can be hidden/slowed down if they are rarely used
  * Memory -- somewhat priveleged. We want fast access to "user memory" but protection from "priveleged memory" and memory from other processes.
      - techniques for this: virtual memory, page tables, etc
  * I/O -- priveleged (need system calls)
  * Time:
      - what if the user's program loops?
      - can be controlled by the kernel if necessary

<h4>Virtualizable Processor</h4>

* hardware that efficiently supports virtual machine (since 1960s)
* Performance issues are introduced
* So, we introduce the notion of a process.
    - a program in execution in an isolated domain
        + domain: virtual machine
        + Process: program running on the virtual machine.
    - Fork system call creates a process.

---

<h4>How to model OS resources in a user program</h4>

  * Resources: files, processes, I/O devices, etc
  * Method A: use pointers
      - model an OS resource like an object, and have a reference to that object.
          + Direct memory access to regions of memory
      - Pros
          + simple
          + fast
      - Cons
          + protection from other programs
          + races
              * multiple process trying to access the same resources
  * Method B: Handlers
      - an opaque ID
      - Assigns a random number (typically an integer) to A process
      - int file descriptors
      - pid_t process IDs
      - ino_t inode #s
      - To get or use a handle, you need to use a system call
      - Handles in good operating sytems avoid races, but not always.
      - Pros
          + Protection
          + Some race protection
      - Cons
          + Slower (need to use system calls)
          + more complex

---

<h4>Flexibility in hooking things together</h4>

  * Many kinds of resources
      - Storage devices (flash, disk)
      - stream devices (network, serial ports, etc)
      - RAM
      - files (parts of storage devices)
      - directories(meta info about the file organization)
      - pipes
      - processes
      - ...
  * In the UNIX family of OSs (UNIX, POSIX, LINUX, etc), these resources are modeled as files
  * `open("/dev/dsk/sd/0", O_RDONLY)`
      - this allows you to just write straight to the disk
      - block devices (reads and writes must be a block at a time)
      - `brwxrw-rw---`
  * `open("/dev/adfsd", O_RDONLY)`
      - for example, a serial device that reads characters (character device)
      - `crw-r--r--r--`
  * `open("/dev/mem", O_RDONLY)`
      - allows you to read memory (VERY STRICT PERMISSIONS)
  * `/proc/`: currently running processes

---

```C
// File API

int open (char const*, int, ...)
ssize_t read(int, char*, size_t)
ssize_t write(int, char*, s8ze_t)
int close(int);
off_t lseek(int, off_t, int)
```

<h4>Limitations of these functions</h4>

  * `lseek` does not work on stream devices, since it assumes it is possible to offset from some point in storage. Meant for storage devices.
  * other such liitations

<h4>Possibly, a more convenient API</h4>

  * `ssize_t readline(int fd, char* buf, size_t sizeOfBuffer, char delim)`
      - acts like read but stops at a newline or another delimiter
      - conventions: returns size, that does not count the newline
      - newline is stored in buffer
      - if t == size, the line was too long.
      - that way, we can tell if the line was too long.
      - Problem: Should we wait for a newline if we are using pipes, or write an incomplete line? solution: use a flag to decide, default to yes.

This added complexity is one of the reasons syscall APIs tend to be as simple as they are.

Functions like readline would normally be implemented as libraries atop system calls, instead of using file descriptors directly.


---

```C
// Process API

pid_t fork(void); // creates a new running process

_Noreturn void _exit(int) // halts the process, argument is exit status

// After calling the exit function, the preocess is now dead, but the process object itself still exists as a Zombie.

pid_t waitpid(pid_t, int * exit_status, int flags) // waits for the process in pid_t wuestion and finally destroys it once its dead

```




<h4>OS Organization</h4> 

   * Interface stability + evolution
       - We need to be able to evolve and upgrade code without making previous code unusable


---
