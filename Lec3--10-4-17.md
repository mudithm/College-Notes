<h1>Lecture 3</h1>



<h3>More about Assembly language and Abstraction</h3>

---

**Abstraction**
A key concept of programming is increasing levels of abstraction

<ul><li>e.g. Multipication can be split into addition, including all the different cases of multiplication (distribution, etc)</li><li><i>Algebra</i>, then, is an abstraction of all of the arithmetic you can do.</li></ul>

*Abstraction in Computer Science*

<ol><li>Voltage levels and currents in a circuit</li><li>General voltage, resistance, capacitance, etc</li><li>binary representations of these differences of voltage</li><li>Storing and Representing integer values by components</li><li>Boolean login by vomponents</li><li>Arithmetic operations on these integers</li><li>physical representations of the data and results stored <i>**now this is at machine language</i></li><li>Assembly language to control these functions in a more accessible manner</li><li>Higher level commands to reference the assembly commands directly</li><li>A high level programming language that is more in line with human language and understanding</li></ol>

----

*Programmers shift down in levels of abstraction to debug and improve the efficiency of their code.*

<ul>*It is rare that a programmer will ever have to go down to the physical/hardware level*

Different models of computers will have varying architectures, memory amounts and integer limits, etc. So machine language is very much dependent on the computer is is written for/on.

Assembly languages are typically modeled toward a particular machine language, so they also vary a good deal.

Assembly was the primary language used in the 50s.
</ul>


>>**Vendor Lock-in:**  Because computers were so expensive and rare, computer manufacturers (vendors) made updated models with relatively good compatibility with older model programs. That said, their languages could vary greatly from other vendors, so even if a cheaper or better alternative was available, it was not feasible to change because all code would have to be rewritten.




IBM eventually gained market share and most of its competitors went out of business




--------------


<h3><b>Higher Level Languages</b></h3>

The first mainstream high level language was FORTRAN in 1957
    FORTRAN

    INTEGER PRICE = 42
    INTEGER FEES = 13
    INTEGER TOTAL = PRICE + FEES


Higher level languages are *compiled.* The "translator" that does this is called the compiler.

>higher level languages like fortran made programming cheaper, although they were still capitalized by IBM (the inbentor of FORTRAN). Their advantage was that compilers could be written for avery computer.



After the development of FORTRAN, new languages were invented for whatever purpose. (Scientific purposes, etc)

The _'C programming language'_ was devd in '1971' by _Bell labs_

Many later languages were developed based on C.

<ul><li>C++ <b>(Late 80s)</b></li><li>Objective-C <b>(Late 80s)</b>  ..... Used mostly by Apple, soon to be replaced by Swift</li><li>Java <b>(90s)</b><ol><li>A rare success, because it had many built-in libraries for many things</li><li>Had an interpreter so that it could run everywhere</li><li>Eventually Microsoft developed <b>C#  (Early 2000s)</b> for windows users because Java refused to include microsoft-specific functionalities</li></ol></li></ul>


Languages that are not checked during compilation:
<ol>   <li>Python</li><li>Ruby</li><li>Perl</li><li>JavaScript</li></ol>

----

_Bjarne Stroustrup and the development of C++_
>Used from 1980
>Released to public in 1985
>Targeted for UNIX operating system

The *International Standards Organization* came up with the international C++ standard in 1998 **(C++ 98)**

2011 ISO Revision **(C++ 11)**
2014 ISO Revision **(C++ 14)**
2017 ISO Revision **(C++ 17)**
Next planned revision: 2020

---

**break**

---


Compilation and Execution occur in seperate steps

Types of errors:
>Compilation / Syntax errors
>Logic / Runtime error


