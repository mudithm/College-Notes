<h1>Lecture 13</h1>

--- 

<h5>Pointers</h5>

  * Another way to implement passing by regerence
  * Traverse Arrays
  * Manipulate Dynamic Storage
  * Represent Relationships in Data Structures

`double&` means reference-to-double or another-name-for-some-double



To generate a pointer in C++, use the `*` operator as follow:

``` c++    
    ...
    int main(){
        double r;
        double angle;
        //......
        double x;
        double y;

        polarToCartesian(r, angle, &x, &y) // When calling a function that requires a pointer, the & means that it generates a pointer to something.

        
    }
                                                        //v This asterisk is necesary to indicate that you are passing a
                                                        pointer
    void polarToCartesian(double rho, double theta, double* xx, double* yy){
        *xx = rho * cos(theta); // Must begin with the * to indicate that you are using a pointer
        *yy = rho * sin(theta);
    }
```

`&x` means "generate a pointer to x" or "address of x"
`*x` means "the object that x points to" or "follow the pointer x"

The C language does not have references, only pointers.


_Pointers to a specific type (eg a pointer to a double) cannot be assigned that type. For example, double* p = &x; could not later be assigned as p = 5.0. The variable can only hold a pointer to a double._ 

Another thing that is that you can initialize a reference.

`double& dd = d;`

The weird thing about this is that they literally refer to the same object. dd is the same thing as d. It would not be a normal thing to do, unless perhaps you are using a multilayered array and want to reference and alter a specific element of the array multiple times without having to use the subscript notation repeatedly.

Another scenario:

    double a = 5.1;
    double b = 4.3;

    double* p = &a;
    double* q = &b;

    p = &b; // Changes the pointer from a (the thing p points to) to b
    *p = b; // Changes the value of a (what p points to) to b


Also, a variable that holds a pointer to a double cannot be reassigned to a pointer to an int, even though an int can be assigned to a double.

If a pointer is initialized without a variable, it will be assigned to a random bit pattern. 

EG

    double* q;
    *q = 3.5;

This will either crash (if the random bit pattern assigned to the pointer represents a memory address outside your program's bounds) or it will overwrite some memory address within your program, or will be assigned to a random value that will likely never be accessed or used.

You can compare pointers of the same type to see if they reference the address of the same object.

A way to change the values of an array using pointers:

    const int MAXSIZE = 5;
    double da[MAXSIZE];
    int k  = 0;
    double* dp;
    for (dp = &da[i]; ...dp...; ...dp...){
        *dp = 3.6;
    }