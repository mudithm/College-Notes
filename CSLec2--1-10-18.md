<h1>Lecture 2</h1>

---

Continuing the Circle class from the previous lecture:

``` c++

    #include <iostream>

    using namespace std;

    class Circle{
        // some memes go here
        // Pretend that there are the proper function
        // declarations here

        public:
            Circle(double xCor, double yCor, double radius);
            void scale(double factor);
            void draw();

        private:
            // Class Invariant:
            // m_r > 0
            double m_x;
            double m_y;
            double m_r;

    };

    double area(Circle c);


    int main(){
        Circle blah(6, -5, 3);
        // We first realize that these seem like reasonable
        // parameters tor a circle. We then decide how to 
        // implement this circle

        Circle c(-2, 5, 10);
        c.scale(2);
        c.draw();

        cout << area(c); // note that in this scenario, the
                         // function area is a non-member 
                         // function. 
    }


    Circle::Circle(double x, double y, double r) : m_x(x), m_y(y), m:r(r)
    {
        if (r <= 0){
            cout << "Cannot create a circle with radius " << r << endl;
            exit(1); // The exit flag ends the process it is called in.
                     // In the above case, the main function will be 
                     // ended
        }
    }
```

You may notice that next to the Circle constructor, there is some strange syntax involving the member variables and the parameters of the function.

This is called an initialization list, and automatically assigns the parameters as listed to the given member variables. This syntax can only be used as part of a member function definition.

---

We will now define the `scale` function:

``` c++

    #include <iostream>

    using namespace std;

    class Circle{
        // some memes go here
        // Pretend that there are the proper function
        // declarations here

        public:
            Circle(double xCor, double yCor, double radius);
            bool scale(double factor);
            void draw();

        private:
            // Class Invariant:
            // m_r > 0
            double m_x;
            double m_y;
            double m_r;

    };

    double area(Circle c);


    int main(){
        Circle blah(6, -5, 3);
        // We first realize that these seem like reasonable
        // parameters tor a circle. We then decide how to 
        // implement this circle

        Circle c(-2, 5, 10);
        

        int f;
        cin >> f;
        if ( ! c.scale(f))
            //... do something;
        
        c.draw();

        cout << area(c); // note that in this scenario, the
                         // function area is a non-member 
                         // function. 
    }


    Circle::Circle(double x, double y, double r) : m_x(x), m_y(y), m:r(r)
    {
        if (r <= 0){
            cout << "Cannot create a circle with radius " << r << endl;
            exit(1); // The exit flag ends the process it is called in.
                     // In the above case, the program will be
                     // terminated
        }
    }

    bool Circle::scale(double factor){
        if (factor <= 0){
            // cout << "The scale factor must be non-negative";
            return false;
        }
        m_r *= factor;
        return true;
    }


```

Notice that we changed the return type of the scale function from `void` to `bool`. This is to allow for higher-level functions to handle errors that cause bad behavior. 

This is a common practice in programming because lower level functions typically do not know what the functions calling them desire, and so are unable to provide an adequate error message or warning. 

Allowing a higher level function to diagnose errors allows for a better experience for both testers and end users.


---

Moving on to the `draw`  and `area` functions:

``` c++

    #include <iostream>
    #include <cmath>

    using namespace std;

    const double PI = 4 * atan(1.0); // This is a trick to get
                                     // the value of Pi as a 
                                     // constant, since only
                                     //newer versions of c++
                                     //contain a Pi constant.

    class Circle{
        // some memes go here
        // Pretend that there are the proper function
        // declarations here

        public:
            Circle(double xCor, double yCor, double radius);
            bool scale(double factor);
            void draw() const;
            double radius() const;

        private:
            // Class Invariant:
            // m_r > 0
            double m_x;
            double m_y;
            double m_r;

    };

    double area(const Circle& c);


    int main(){
        Circle blah(6, -5, 3);
        // We first realize that these seem like reasonable
        // parameters tor a circle. We then decide how to 
        // implement this circle

        Circle c(-2, 5, 10);
        

        int f;
        cin >> f;
        if ( ! c.scale(f))
            //... do something;
        
        c.draw();

        cout << area(c); // note that in this scenario, the
                         // function area is a non-member 
                         // function. 
    }


    Circle::Circle(double x, double y, double r) : m_x(x), m_y(y), m:r(r)
    {
        if (r <= 0){
            cout << "Cannot create a circle with radius " << r << endl;
            exit(1); // The exit flag ends the process it is called in.
                     // In the above case, the program will be
                     // terminated
        }
    }

    bool Circle::scale(double factor){
        if (factor <= 0){
            // cout << "The scale factor must be non-negative";
            return false;
        }
        m_r *= factor;
        return true;
    }

    void Circle::draw() const{
        // Draw a circle with radius centered at
        // (m_x, m-y) with radius m_r

    }

    double Circle::radius() const{
        return m_r;
    }

    double area(const Circle& x){
        return PI * x.radius() * x.radius;
    }


```

In the `area` function, we change the definition to a pass by reference. This is because the resources and time used to make a copy of the `Circle`, ae ths would be the case if it was passed by value, is inefficient, because not all the member variables of the object are used.

This practice is trivial in this case, as only two variable remain unused, but in a larger object with more variables or objects that contain large amounts data.

Also note that the `radius` function must be declared as constant. When a fucntion is called on a variable that is declared as `const`, the compiler must be sure that the function does not have the capability to change the value of the object it is called on. 

The way it does this is by looking at the declaration of the function. Even if the implementation of the function does not modify the parent object, the compiler will flag the function if it is not declared with `const`. This is because in many programs, only the declaration is available and the function definition is contained in another file.

---

In a larger program, the __compiler__ compiles each individual c++ file (and creates an object file) and the __linker__  will patch together the various files and references that the program consists of to form a valid executable.

If changes are made to only a single file, only that file will have to be recompiled, and all of the object files will be pretty much the same. This will be a much faster process than keeping all the code in a single file and having to recompile the entire program every time you attempt to fix a bug.

This concept is called _separate compilation_

In c++, the compiler will only look at the individual source file and any header files it contains (this is the reason for some of the code above). 

In Java, the interpreter will comb through functions in other files in a more complex manner.

------

Separating the above code into a few different files, as follows:

```c++
//==============================
//circle.h
const double PI = 4 * atan(1.0);

class Circle{
        // some memes go here
        // Pretend that there are the proper function
        // declarations here

        public:
            Circle(double xCor, double yCor, double radius);
            bool scale(double factor);
            void draw() const;
            double radius() const;

        private:
            // Class Invariant:
            // m_r > 0
            double m_x;
            double m_y;
            double m_r;

    };


```


```c++
//=================================
//myapp.cpp
#include "circle.h"
#include <iostream>

using namespace std;

int main{
    Circle blah(6, -5, 2);
    Circle c(-2, 10, 5);
    c.scale(3);
    //.....
}

```

```c++
//================================
//circle.cpp
#include "circle.h"
#include <iostream>

using namespace std;


//All the circle class functions should be defined here

    Circle::Circle(double x, double y, double r) : m_x(x), m_y(y), m:r(r)
    {
        if (r <= 0){
            cout << "Cannot create a circle with radius " << r << endl;
            exit(1); // The exit flag ends the process it is called in.
                     // In the above case, the program will be
                     // terminated
        }
    }

    bool Circle::scale(double factor){
        if (factor <= 0){
            // cout << "The scale factor must be non-negative";
            return false;
        }
        m_r *= factor;
        return true;
    }

    void Circle::draw() const{
        // Draw a circle with radius centered at
        // (m_x, m-y) with radius m_r

    }

    double Circle::radius() const{
        return m_r;
    }

```


The first file is a header file, `circle.h`, which contains the class definition of `Circle`. this is included because all of the files require this definition and it would be repetitive to include it in both of the cpp files.

The double quotes around the `circle.h` in theinclude statement indicate that the header file will be found in the same directory.

Angle brackets, on the other hand, indicate to that the files mentioned are either part of the compiler or in a standard location known to the compiler.

>A note: do not include .`cpp` files. This might result in duplicate function definitions. Even if these definitions are the same, the linker will throw an error and the executable will not be built.


---

Another Example:

```c++
//============================
//point.h

#ifndef POINT_INCLUDED
#define POINT_INCLUDED

class Point{
    //...
}

#endif // POINT_INCLUDED
```

```c++
//============================
//circle.h

#ifndef CIRCLE_INCLUDED
#define CIRCLE_INCLUDED

#include "point.h"

class Circle{
    //...
    double m_radius;
    Point m_center;
}

#endif // CIRCLE_INCLUDED
```

```c++
//============================
//myapp.cpp

#include "circle.h"

int main{
    Circle c(...);
}

```


The above Circle file uses the Point object, do it needs to include the header file associated with the Point.

In the `point.h` header file, we see some more curious syntax. This circumvents any issues that may result from including the same header file multiple times in the same compilation. This is called a _include guard_, and should be included in any header file. 