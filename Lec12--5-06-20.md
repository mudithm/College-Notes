<h1>Lecture 12</h1>

---

<h3>Secure Signature Scheme</h3>

  * $.x $h : 0(n<sup>2</sup>) &rarr; n
      - s.t. it is hard to find a collision on x, then a secure signature scheme exists.
  * Going from n<sup>2</sup> to n bits.
  * __F12.1__

<h3>MAC</h3>

  * Message Authentication Code
  * __F12.2__
  * a sends b m, &alpha;
  * In order for Eve to guess what &sigma;(m') should be, she would have to guess the other point on the line, and there are an infinite number of possibilities for this. Note that she *might* know what m, MAC<sub>a, b</sub>(m) is.

<h3>Universal one-way Hash Function</h3> 

  * __F12.3__
  * claim: no polytime adversary can find x<sub>2</sub>
  * Claim (stronger): N-Y construction of UOWHF is secure assuming one-way permutations exist
  * Proof: we are givn a breaker adv. for UOWHF, construct inverter for 1-way perm.
  * __F12.4__ 
  * although a and b might look non-random, they are actually random bc y is the result of a OWF (random) so they look random
  * To actually use this result, we want to go from 4n<sup>2</sup> &rarr; n
      - So we compose the functions as follows: __F12.5__
          + if we can find a collission for any one of these steps, we can use it to solve a one-way permutation; so, this is impossible

---

<h3>Naor Theorem</h3>

  * Thm[NAOR]: if &exist; PRG then &exist; bit commitment protocol
  * Thm[HILL]: 1-way functions exist iff PRG's exist.
      - __F12.6__
      - C is the commiter, R is the receiver
      - fulfils both hiding and binding
          + hiding: no poly-time reciever can predict b with prob &gt; 1.2 _ &epsilon; (after commit phase)
              * if not, could distinguish random from pseudorandom
          + binding: after commit phase, committer cannot open committed 
              * proof with cheatable strings (random string happens to be x<sub>1</sub> xor x<sub>2</sub>)