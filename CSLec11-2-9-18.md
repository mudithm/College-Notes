<h1>Lecture 11</h1>

---

Code from last lecture:

```c++

class Shape{
    public:
        virtual void move(double xnew, dobule ynew);
        virtual void draw() cosnt = 0; // pure virtual function
    private:    
        double m_x;
        double m_y;
};

class Rectangle : public Shape{
    virtual void draw() const;
    virtual double diag() const;
    double m_dy;
    double m_dx;
};

void Shape::move(double xnew, double ynew){
    m_x = xnew, m_y = ynew;
}

void Rectangle::draw() const{
    // Draw a rectangle
}

void Rectangle::diag() const{
    return sqrt(m_dx * m_dx + m_dy * m_dy);
}

```

---

Say we define the function `f()` as follows:

```c++

void f(Shape* sp){
    sp->draw();
}

```

If we don't define the `draw()` function for a rectangle, it will inherit `Shape`'s `draw()` function. This would make Shape an abstract class, since `draw()` is a pure virtual function. Since an error would occur whenever a rectangle was initiated (you cannot create an object of an abstract type), this function would never in itself be the cause of an error.

---

Updating the code with a circle class:

```c++

class Shape{
    public:
        Shape(double x, double y);
        Shape();
        virtual void move(double xnew, dobule ynew);
        virtual void draw() cosnt = 0; // pure virtual function
    private:    
        double m_x;
        double m_y;
};

// ...

class Circle : public Shape{
    public:
        Circle(double r, double x, double y);
        Circle(double r);
    private:
        double m_r;
}

Shape::Shape(double x, double y) : m_x(x), m_y(y)
{}

// default constructs a shape at the origin
Shape::Shape() : m_x(0), m_y(0)
{}

// ,,,}

// constructs a circle with given radius and coordinates
Circle::Circle(double r, double x, double y) : Circle(x,y), m_r(r)
{}

// constructs a circle with given radius at the origin
Circle::Circle(double r) : m_r(r)
{}
```

The circle constructor makes use of the shape constructor, and the second uses the default shape constructor.

In C++ 11 and later, we can also define the second Circle constructor (the one that creates a circle at the origin) using a "delegating constructor" as follows:

```c++

Circle::Circle(double r) : Circle(r, 0, 0)
{}
```

This calls the first constructor with the arguments listed.

---

```c++
class Polygon : public Shape{
    // some code here
    ~Polygon();
    /// some more
    Node* vertexOffsets;
}

// More code here

Polygon::~Polygon(){
    // Walk throgh the list, deleting each node.
}


void f(){
    // creaates an array of shapes.
    Shape* pic[100];

    pic [i] = new Polygon(/*some arguments*/);

    for (int i = 0; i < /*some bound*/; i++)
        delete pic[i];
}

```

The problem with this implementation is that, since the destructor of shape is not virtual, the decision of which destructor to call on `pic[i]` is done by the compiler. All that is known at compile time is that `pic[i]` is a shape, so the polygon destructor will not be called.

To fix this, we declare the destructor of shape to be virtual. This means we have to name it and implement it. Any classes that do not implement their own destructors will inherit the default, and those that need a specialized destructor can implement one themselves.

Code:

```c++

class Shape{
    // ...

    virtual ~Shape();
}

Shape::~Shape(){

}

```

Because we declare the function virtual, it will by default not be created by the compiler. We need to do it ourselves.

After this, polygons should be destructed properly.

If a class is designed to be a base class, declare its destructor to be virtual, and implement it. This will save you from a lot of potential headache.

---

A sorting algorithm for an unsorted pile of items

```c++

sort(/*some unstorted list*/){
    // Split the pile evenly into two unsorted subpiles
    // get the left unsorted subpile sorted
    // get the right unsorted subpile sorted
    // merge the two sorted subpiles
}

```

We can tackle this using recursion.

```c++

sort(/*some unstorted list*/){
    // Split the pile approx evenly into two unsorted subpiles
    sort(the left unsorted subpile);
    sort(the right unsorted subpile);
    // merge the two sorted subpiles
}

```

This implementation seems good so far, but we need some kind of ending condition to stop the recursion.

```c++

sort(/*some unstorted list*/){
    if (list.size() >= 2){
        // Split the pile approx evenly into two unsorted subpiles
        sort(the left unsorted subpile);
        sort(the right unsorted subpile);
        // merge the two sorted subpiles
    }


}
```

The end condition here is known as a base case. All recursive functions must have these, meaning that there must be some way for the function to return.

To show that a recursive solution terminates:
    
  * there has to be at least one base case
      - i.e. a way to get through the function without making any recursive calls
  * every recursive call is to serve a strictly smaller instance of the problem
      - i.e. one that is closer somehow to a base case




```
