<h1>Lecture 2</h1>
*Introduction to Databases and the Relational Model*

---

<h2>Introduction to Databases</h2>

---

<h3>Last time</h3>

  * Problems with using a flat file system to store data
  * How UCLA used to use such a system for student records
  * Problems:
      - Data Integrity and Redundancy
      - Sysadmin is the bottleneck
      - Lack of Atomicity
      - Concurrent Access
      - Security        
  
<h3>Database</h3>

  * For most of this course, this means a RDBMS, for Relational Database Management System

<h3>Database Purpose</h3>

  * Abstracts away how the data is stored, maintained, and processed
  * Big data and distrib'd systems, such as Spark, have reintroduced the importance of understanding how data is laid out on disks/nodes, but for now we won't discuss it
      - how data is laid out can have a huge impact on performance
  * A data base provides:
      - a way to view, add, update, and delete data without worrying about files and breaking data integrity
      - one single location (logically, not necessarily physically)

<h3>Databases and Data Structures</h3>

  * Databases are little more than specialized data structures on disk/ssd

---

<h3>Levels of Abstraction</h3>

  * DBs provide three layers of abstraction
      - Physical: how the data are stored
          + MySQL has 9 storage engines, most importantly, MyISAM and InnoDB
          + PostgeSQL has only one.
      - Logical
          + describes how users interact w/ and see data
      - View
          + gives a view into the data
          + used for a specific app, where you might need only specific fields

<h3>Logical Abstraction</h3>

  * A logical abstraction is a way of abstracting the structured type, like you'd see in C.

```c
struct Section
{
    int srs; // unique ID number for this section
    int cap; // max number of students allowed
    int instructor_uid; // TA or instructor info
    int parent_srs; // link to the lecture
}
```

---

<h3>Instances and Schemas</h3>

  * The info stored in a database at a particular point in time is called an `instance`. This terminology has been resurrected by its use with AWS
  * The overall design of the DB is a `schema`
  * The term schema is sometimes used interchangeably to describe the logical structure of a `database` or `relation` (ie in PostgreSQL, the schema is all the tables in the DB)
  * A `subschema` refers to the design of a particular part of the db
      - We usually still call it a schema if it refers to a DB or a table
  * Analogous to variable declarations and classes containing variables
      - each class obj is an instance of the class, with a set data type

<h3>Data Model</h3>

  * Data models define how users interact w/ data
      - how we can get a descr. of the data
      - how we encode relationships among data
      - how we impose constraints on the data
  * There are 5 major types

<h3>Relational</h3>

  * Data stored as a table. Rows represent ind units called records or tuples
  * Cols represent attrs common to all records and have specific types

| bldg | floors | wifi_access_pts | resident_rats |
| --: | :-: | :-: | :-: |
| Boelter | 9 | 251 | 0 |
| Engineering VI | 5 | 204 | 1 |
| SAC | 3 | 98 | 0 |
| ... | ... | ... | ... |


<h3>Entity-Relationship (ER)</h3>

  * Uses a collection of basic objs called entities and the relationships among them. Typically used to visualize a db design


<h3>Object Oriented</h3>

  * Draws a strong analogy to obj-oriented programming with encapsulation, methods and object identity
      - Data are essentially treated as instances of classes rather than tables
      - Examples incl Java Data Objects, Gemstome, Cache, Versant


<h3>Document (Previously Semi-Structured)</h3> 

  * Individual data objects may have diff sets of attrs
      - Records may or may not share some base attrs
      - records can have their own unique attrs
      - many common semi-structured data types can be converted into the relational model
      - JSON and XML are two examples of data types that are natural for the semi-structured model
      - Very important to know how to use these data formats
      - Other examples in NoSQL databases

<h3>Network/Hierarchical/Graphs</h3>

  * Actually predates relational model
  * Defines data records as nodes, and relationships between records as edges
  * One notable NoSQL example is neo4j
      - Network model:
          + individual edges form the mapping
      - entity/relationship
          + mapping is contained within an explicit entity

---

<h3>Database Languages</h3>

  * Two main semantic systems for working with Databases
      - Data Definition Language (DDL)
      - Data Modification Language (DML)
      - For the relational model, usually both SQL

---

<h3>Data Manipulation Language (DMLs)</h3>

  * Procedural
      - User specifies what data are needed and how to get it
  * Declarative
      - Users specifies what data, but not HOW to get it
  * A `query` is a written expression to retrieve or manipulate data
  * a `query language` is simply the language it is written in
      - Note that JavaScript can be a query language

<h3>SQL in particular</h3>

  * SQL queries take one or more relations and outputs a *single* relation as a result.
  * Example:
  * Suppose we have a simple relation called `student_dorms` that contains each building, its number of floors, and number of residents:

```sql
SELECT bldg
FROM student_dorms
WHERE residents > 100;
```

  * Multiple constraints:

```sql
SELECT bldg
FROM student_dorms
WHERE residents < 200 AND floors > 3;
```

  * SQL is not a procedural language. There are computations that cannot be easily done with SQL
      - Sequential computations
      - any computation where the user has to specify HOW to perform the computation

<h3>When SQL isn't enough</h3> 

  * Write an ETL job in your favorite language
      - **E**xtract data from the DB using a DB connection driver such as ODBC for C (Open DB Conecc.) or JDBC (Java DB COnn.)
      - **T**ransform the data using your language
      - Use the driver to write the data (**L**oad) back into a new table. Pretty much every language has drivers for the most common databases
  * If you don't need the resulting data to be written back to the database, you can skip the load step.
  * Another way to do this is to dump the data to disk manually and process it, but this is accident prone
  * In industry, ETL jobs are usually scheduled using something like `cron`.

---

<h3>Data Definition Language (DDL)</h3>

  * The DDL specifies a Schema:
      - collection of attr names and data types
      - consistency constraints
      - optionally, storage structure and access methods
  * There are several types of constraints a DDL can specify
      - Domain Constraints
          + restrict the types of values in a particular field (eg size of numbers, range, etc)
          + these are checked every time a query that accesses/modifies that field is called (will report errors)
      - Referential Integrity
          + Any relationship between tables is kept intact (ie, no dangling records, etc)
              * An instructor in the courses table must be defined in the instructors table
                  - foreign key relationship
      - Assertions
          + constraint on data. Example:
              * a student cannot take more than 21 units
              * student cannot retake a course unless they received a c- or below, etc
      - Authorization
              * restrict access to certain tables/data so that only certain accessors can modify/see data
                  - eg, a user shouldn't be able to change how much they owe a business

---

<h3>Data Storage and Querying</h3>

  * Databases also have a storage manager, that allows us to typically not worry about how the data is laid out on disk
  * DBs can be on the order of GBS to TBs, even PBs
      - Most of this data cannot fit in RAM, and must be read in from the disk
          + This must be done efficiently because reading from the disk is *very* slow.
  * The storage manager has the following duties:
      - Authorization and data integrity checks
          + checks auth and integrity constraints
      - Transaction Management
          + handle concurrent transactions, traffic control, etc
      - File manager
      - Buffer manager
          + handles RAM management for the data
  * The storage manager uses a few of its own RAM and Disk-based data structures
      - Data files
      - Data dictionary
      - Indices
          + index the data for quick lookup
  * One data structure you have used in programming that can be used as an index in your code is the hash table (hash map, dict)
      - others are binary trees, tries etc

<h3>Query manager</h3>

  * When a query is executed, the DML statements are org'd into a query plan, which consists of low-level instructions to perform the operation
  * important for debugging problems in queries
      - EXPLAIN keyword

---

<h3>Duplicated Data</h3>

  * we want to reduce duplicated data in a database
  * Normalization

---

<h3>Database Architectures</h3>

  * Server/client
  * Distributed

<h3>Server/client model</h3>

  * One centralized db, clients access the DB directly
      - problems: single point of service, consistency issues, etc

<h3>Distributed architecture</h3>

  * Several db servers that may
      - Contain identical data (replicated)
      - contain different pats of the data (sharded)
  * each server may coordinate with a master Db or exchange data amongst themselves (eventual consistency) or via caches (real-time access use case)
  * Example: different servers for different locations, along with an optional master database server

---

<h2>Introduction to the Relational Model</h2>

---

<h3>What is a Relation</h3>

  * A relational DB consists of a collection of relations (often called tables)
  * Each relation consists of records and attributes
  * Each row is a record, with a set of attrs that are related to that record
  * Each column represents a particular attribute, has a unique name, and a particular data type

<h3>Example: Youtube videos and comments</h3>

Records from a relation containing information on a large number of US youtibe videos that were crawled by a researcher

| video_id | title | channel | cat_id | views | likes | dislikes |
| --- | --- | --- | --- | --- | --- | --- |
| aksdjfhlkujg | This is a title | CollegeHumor  | 15 | 321564 | 23550 | 1250 |
| ... |  ... | ...  | ... | ... | ... | ... |

Records from a large number of comments on US Youtube videos y

| video_id | comment_id | comment | likes | replies |
| --- | --- | --- | --- | --- |
| aksdjfhlkujg | asdfk | "Hello there this is a comment" | 0 | 0 |
| ... | ... | ...| ... | ... |

  * Each record in the first relation refers to an individual video
  * Each rec in the second relation refers to an individual comment on some video
  * Videos are identified by a unique identifier, the video_id
  * Comments are identified by a unique identifier, the comment_id
  * A record in the Comment table is related to one in the Video table by the video_id
  * All attributes in the same record are related to each other bc each record represents an individual entity -- a video or a comment
  * Bottom line: a relation is a set of tuples, where each tuple has the same number of attributes.

<h3>Getting Relational</h3>

  * Each attr has a domain, a set of legal vals
  * An attr can have a null value, meaning it is unknown or does not exist, depending on the DDL
  * We can write a schema for our youtube vid as follows:

```sql
youtube_video(video_id, title, channel, cat_id, views, likes, dislikes)
youtube_comment(video_id, comment_id, comment, likes, replies)
```
  * Tuples with the same unique identifier cannot be duplicated in one relation

---

<h3>Superkey</h3>

   * A superkey is a set of one or more attrs that uniquely identifies a tuple and distinguishes it from all other tuples


<h3>Candidate key</h3> 

  * Since a superkey uniquely identifies a tuple in a relation, no two tyuples may have the same values for all of the attrs in K. A superkey that is minimal (has the fewest possible attrs) is called a candidate key
  * A candidate key chosen by the DB designer is more commonly called a Primary Key
  * A primary key must be unique, and cannot be NULL. 