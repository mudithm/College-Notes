<h1>Lecture 12</h1>

---

<h3>Agenda</h3>

  * Closure properties (of families of languuages and application to prove language not in a family)
  * Pumping lemma for CFL's
  * Variations on Automata (including Deterministic PDA)

---

<h3>Closure Properties of a Family of Languages</h3> 

  * EG R<sub>1</sub> and R<sub>2</sub> are FSL's
      - Then we know
          + R<sub>1</sub> &xcup; R<sub>2</sub>
          + R<sub>1</sub> &xcap;  R<sub>2</sub>
          + R<sub>1</sub><sup>&ast;</sup>
          + <div style="border-top: 1px solid black; width: 1.1em;">R<sub>1</sub></div>
          + ...
      - Are also FSL's
  * Suppose S &xcap; R<sub>1</sub> = N<sub>1</sub>
      - N<sub>1</sub>, N<sub>2</sub>, ... could be {0<sup>n</sup>1<sup>n</sup>}, {w|#(0, w) = #(1, w)}, {ww}...
          + known non-FSLs
  * Given that a language L is not finite state,
      - L<sub>=</sub> = {w|#(0, w) = #(1, w)}
  * Proof L<sub>=</sub> not FSL
      - For contradiction, suppose L<sub>=</sub> were FS.
      - Then since 0*1* is FS, so should be 0*1* &xcup; L<sub>=</sub> = {0<sup>n</sup>1<sup>n</sup> | n &ge; 0}
      - However, we know that this is not Finite State -- this is a contradiction
      - So L<sub>=</sub> cannot be Finite State either.
  * Note that you can do this with any operation under which FSLs are closed
  * Also, this can only disprove something -- it means nothing if you prove that an operation results in an FSL.
      - eg intersection with the empty set gives the empty set, which tells us nothing but is an FSL.

---

<h3>Watch out for this example</h3>

  * Suppose S &sube; R, R &sube; S etc.
  * Subset is not a closure property, so this doesn't tell us anything about whether or not these languages are FSL's.

---

<h3>Pumping Lemma for CFL's</h3>

  * If L is a context-free language over &Sigma;, then there exists a number, p, depending only on L such that:
      - For all strings s &isin; L, if |s| &ge; p, then
          + s = u v x y z
          + for all i &ge; 0, u v<sup>i</sup> x y<sup>i</sup>z &isin; L
          + |vy| &gt; 0 (ie |v| > 0 or |y| > 0 or both)
          + |vxy| &le; p
      - Note that the substring vzy could be *anywhere* in s, i.e. u and/or z could be &epsilon;
  * You can divide the string into 5 pieces, and the pieces either side of the middle one have to be at most p symbols from eachother, and the concatenation of the two must be non-empty

---

<h3>Example: Application of CFL Pumping Lemma</h3>

  * &Sigma; = {a, b, c}
  * L = {a<sup>i</sup>b<sup>i</sup>c<sup>i</sup> | i &ge; 0}
  * Suppose L were a CFL and let P be the pumping number. Then consider 
      - s = a<sup>p</sup>b<sup>p</sup>c<sup>p</sup>
      - |s| &gt; p, s &isin; L so we know
      - we can write s = u v x y z so that |vxy| &le; p, |vy| &ge; 1, for all i &ge; 0, u v<sup>i</sup> x y<sup>i</sup>z &isin; L
  * Consider s' = u v<sup>0</sup> x y<sup>0</sup>z = uxz
      - s = a<sup>p</sup>b<sup>p</sup>c<sup>p</sup>
      - |vxy| could
          + straddle two letters
              * ie a<sup>n</sup>b<sup>m</sup>, n + m &le; p
          + be entirely enclosed in a single letter
              * ie all a's (a<sup>n</sup>, n &le; p)
          + in total, 5 cases.
              * We can somewhat generalize the argument to 3 cases
  * If |vxy| is only in one block of letters, then no other block will be changed. This block will have fewer symbols than the others, and will therefore no longer be in the language.
  * Otherwise, if |vxy| straddles two blocks, then the remaining block will not be affected, and will as a result have a greater number of blocks than at least one of the straddled letter blocks.
      - Simplify to 1
      - |vxy| &le; p means it can only affect at most two adjacent blocks. |vy| &ge; 1 means at least one block will be affected. Thus, there will always be at least one unaffected block, and so the number of a's, b's and c's cannot be the same. This indicates that s' is not in the language, which is a contradiction, and so the pumping lemma fails and L is not a CFL.