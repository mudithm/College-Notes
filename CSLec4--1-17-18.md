<h1>Lecture 4</h1>

---

Member functions of a certain type are not able to access private members of other classes, even if a variable of that class is included in the outer class.


```c++
class Circle{
    // Some stuff here
};

class StickFigure(){
    //some more stuff here

    private:
        Circle m_head;
}

// some implementation functions here

StickFigure::StickFigure() : m_head(/*whatever is necessary*/) {
    //some code here
}
```

A constructor can be called in a member initialization list, as shown above

---

Before there was a C++ standard, programmers had to define their own `string` variables. One such definition is described below:

```c++
class String(){
    public:
        String(const char* value);
        string();
    private:
        char m_text[100];
}
```

Limitations of these types of designs:
  1. Have to define a fixed size limit (arrays need to have defined length at compilation)
  2. Not as efficient for smaller strings, may not be long enough for longer strings.

Another definition:

```c++
class String(){
    public:
        String(const char* value);
        string();
    private:
        char* m_text;
        int m_len;
}

String::String(const char* value){
    m_text = value;
    m_len = strlen(value);

}
```

In this case, we store only a pointer to a string, and we can define the length of the string at its definition.

We can also use the built in `strlen` function to compute the length of the string.

---

Testing the above code:

```c++

int main(){
    String x("Wow!");
    // verify that x is "Wow!"

    char buffer[1000];
    cin.getline(buffer, 1000);
    String s(buffer); // Suppose that the user types "Wow!"
    // Verify that s is "Wow!"
    cin.getline(buffer, 1000); //Suppose that the user types 
                               // "Ouch!"
    // verify that S is "Wow!"
    // Fails this test! the string in the above definition 
    // is mutable outside of the String.
}
```

Because this definition allows the `string` to be modified without invoking the `string` variable itself, it exhibits problematic behavior.

To fix this, we tweak our definition of `String`:

```c++
class String(){
    public:
        String(const char* value);
    private:
            //Class invariant:
            //  m_text pints to a dynamically allocated array
            //      of m_len + 1 characters
            //  m_len > 0
            //  m_text[m_len] == '\0'

            //Optional: in a better implementation
            //  OR
            //  m_text == nullptr
            //  m_len == 0

        char* m_text;
        int m_len;
}

String::String(const char* value){
    m_len = strlen(value);
    m_text = new char[m_len + 1];
    strcpy(m_text, value);
}
```

Dynamic allocation should take care of this issue.

Interestingly, although you cannot initialize an array at compilation with a variable as the length, you _can_ dynamically allocate an array with a variable as the length. This is because dynamic allocation is done during execution, not compilation, and the values of the variable will be known at this time. 

(If the length variable itelf is uninitialized, there will be an error, but for different reasons).

---


```c++
class String(){
    public:
        String(const char* value);
        String();
    private:
            //Class invariant:
            //  m_text pints to a dynamically allocated array
            //      of m_len + 1 characters
            //  m_len >= 0
            //  m_text[m_len] == '\0"
        char* m_text;
        int m_len;
}

String::String(const char* value){
    m_len = strlen(value);
    m_text = new char[m_len + 1];
    strcpy(m_text, value);
}

String::String(){
    m_len = strlen("");
    m_text = new char[m_len + 1];
    strcpy(m_text, "");
}
```


The second constructor for String is interesting in that it is identical to the first except that the value is taken as the empty string.

We can consolidate this code as follows, using a feature of C++:

```c++
class String(){
    public:
        String(const char* value = "");
    private:
            //Class invariant:
            //  m_text pints to a dynamically allocated array
            //      of m_len + 1 characters
            //  m_len >= 0
            //  m_text[m_len] == '\0"
        char* m_text;
        int m_len;
}

String::String(const char* value){
    m_len = strlen(value);
    m_text = new char[m_len + 1];
    strcpy(m_text, value);
}

```

This will act normally if the String constructor is called with an argument, and will default to the empty string if no argument is passed.

Note that you must only specify the default value once. Common practice is to put it in the prototype.

If, however, you supply multiple default arguments in a function, you must not pass any subsequent argument. Also, you cannot have an argument without a default after an argument with one.

EG:

```c++
//Declaration:
void f(int x, int y, int b = 1, int c = 54); // VALID
void g(int x, int y, int b = 1, int c); // INVALID

// ....
// Implementation:

h(5, i6, 7, 9); // VALID
h(5, i6, 7); // VALID
h(5, i6); // VALID
h(5, i6, , 9); // INVALID
```

---

We will now implement a destructor for the `String` class:

```c++
class String(){
    public:
        String(const char* value = "");
        ~String();
    private:
            //Class invariant:
            //  m_text pints to a dynamically allocated array
            //      of m_len + 1 characters
            //  m_len >= 0
            //  m_text[m_len] == '\0"
        char* m_text;
        int m_len;
}

String::~String(){
    delete [] m_text;
}
```

Note that since `m_text` was initialized with the syntax `new type []`, it must be deleted with `delete [] varName;`

---

This code seems fairly flushed out, but another problem might arise.

```c++
void g(){
    String s("Hello");
    f(s);
}


```


To be continued...