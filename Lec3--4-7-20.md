<h1>Lecture 3</h1>

---

<h3>Agenda Week 2</h3>

  * Zoom
  * HW Notes
  * Formal Model of finite automation
      - Finite state languages
      - Examples
  * NFA
      - Classes of Languages
      - Closure Properties
  * Regular Expressions


---

<h3>Homework Review</h3> 

  * The empty set concatenated with anything is the empty set
  * the empty set crossed with anything (Cartesian Prod) is the empty set
      - This is both by definition of these operations
  * Note: concatenation is for sets; if you want to concat a single word, you should concat the set with only that word as an element
      - ie {w} &sdot; L

---

<h3>Graphs and Strings</h3>

  * __F3.1__ 
  
  let &Sigma; = {a, b, c, ..., z, 0, 1, 2, ..., 9, +, -, `>`, `<`, begin, end, if, then, ",", ";", "(", ")"} mag = 35 symbols
  ifcounter`<`maxthencounter=counter+1; mag = 11 symbols
  omething like this)


---

<h3>Compilers</h3>

  * Every compiler consists of 
      - a sequence of symbols (characters)
      - __F3.2__
      - if u is a substring of w, and u &ne; w, u is a proper substring
          + NOT &epsilon; -- it can be a substring of any string or a prefix/suffix to any string, but not a proper substring.
      - proper prefix: r is a proper prefix of w if r &ne; w and &exist; v st rv = w
      - Proper suffix: similar
          + &epsilon; CAN be a proper prefix or suffix any non-&epsilon; word

---

<h3>String notation</h3>

  * Given &Sigma;, w 
      - w<sup>R</sup> &equiv; w written with the order of the symbols reversed
  * a<sup>n</sup> = a...a (length n)
  * w<sup>n</sup> = w...w (length n)
  * L<sup>n</sup> = L &sdot; L &sdot; ... &sdot; L
  * w = w<sub>1</sub> &sdot; w<sub>2</sub> &sdot; ... &sdot; w<sub>k</sub>
  * w<sup>R</sup> &equiv; w<sub>K</sub> &sdot; w<sub>K-1s</sub> &sdot; ... &sdot; w<sub>1</sub>
      - For 1 &le; i &le; k, w<sub>i</sub> &isin; &Sigma;
  * Not in Sipser:
      - #(a, w) &equiv; the number of occurrences of the symbol `a` in the word `w`
          + where a &isin; &Sigma;, w is a word over &Sigma; (w &isin; &Sigma;*)
      - Examples
          + #(a, aab) = 2
          + #(a, bb) = 0 = #(a, &epsilon;) 
  * Note: for the purposes of this course, there is no empty symbol (symbol is an element of an alphabet, and an alphabet is any finite set not containing &epsilon;)

---

<h3>Formal Definition of Deterministic Finite Automata</h3>

  * Deterministic Finite Automaton: M = (Q, &Sigma;, &delta; q<sub>0</sub>, F), where
      - Q = finite set (states)
      - &Sigma; = finite set (alphabet)
      - q<sub>0</sub> &isin; Q (the initial state)
      - F &subset; Q (the accepting states)
      - &delta;: Q x &Sigma; &rarr; Q
          + &delta;(q, a) = q' is interpreted as: In state q on input a, go to state q'. Each move consumes one input symbol 'a'.
          + This is the "transition function"
  * Initial configuration of M:
      - init state q<sub>0</sub> with the input on the input tape and the input tape head at the first sumbol of the imput.
  * Define comuptation of M on input w = w<sub>1</sub> w<sub>2</sub> ... w<sub>m</sub>:
      - A sequence of legal moves from the initial state, proceeding as long as there are legal moves to make. Formally, 
          + There exists a sequence of states of M, q<sub>0</sub>, q<sub>1</sub>, ... q<sub>m</sub> &isin; Q such that
              * For all 0 &le; i &le; m-1, &delta;(q<sub>i</sub>, w<sub>i+1</sub>)
  * The computation is accepting if q<sub>m</sub> &isin; F, otherwise it is rejecting. Also, if a DFA does not have any legal move to make at some step *before* reaching the end of the input string, then the computation "blocks" and rejects.
  * We can extend the def of &delta;() over Q x &Sigma;<sup>*</sup>, recursively / inductively on the length of the input string:
      - Define &delta;<sup>*</sup> : (Q x &Sigma;<sup>&ast;</sup>) &rarr; Q:
          + &delta;<sup>*</sup>(q, &epsilon;) &equiv; q, for all q &isin; Q
          + &delta;<sup>*</sup>(q, ay) &equiv; &delta;<sup>&ast;</sup>( &delta;<sup>&ast;</sup>(q, a), y), for all q &isin; Q, a &isin; &Sigma;, y &isin; &Sigma;<sup>&ast;</sup>
      - Structural Recursion
  * This is the transitive closure of &delta; w/r to the second argument, &Sigma;

---

<h3>Homework 2</h3>

  * First is to take a language from last week and write a machine for it
      - NFA
  * Last problem: NFA or a DFA
  * Problem 2: d
  * Problem 3: directed rooted ordered tree
      - in the homework