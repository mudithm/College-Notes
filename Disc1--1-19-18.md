<h1>Discussion 1</h1>

---

<h4>Copy Constructor</h4>

```c++

class A{
    // ..Some value here..
}

int main(){
    A obj1(5);
    A obj2(10);

    obj1 = obj2;
}
```

This code will not compile. You cannot directly assign the value of one object to another unless a copy constructor is defined. (Unless you use a pointer to the object)

This is because there is no default definition for copying the members of a class in C++. 

A copy constructor should use a deep copy, which copies the value of the data members of an object and not just the shallow info.

Example:

```c++

A::A(const &A o){
    x = o.x;
}
```

A copy constructor must be defined with a parameter passed by `constant` reference. This is for two reasons: in order to pass a parameter by value, a copy must be made, which will need a copy constructor, which needs to copy something, etc. So this will cause a compilation error.

The reason to pass this as `const` is in case you need to copy a temporary value (for example, a function that returns a value that is an oboject)

```c++ 
A foo(){
    A meme;
    return meme;
} 

int main(){
    A obj = foo();
}
```

Since functions return temporary values (which will be soon removed from memory)

---

An analog to the copy constructor for assignment is the assignment operator.

The copy constructor is used when a new object is created, and an assignment operator is used when an already created object has its value changed.

```c++

A ob1;
A ob2 = ob1; // Copy constructor

A ob3;
A ob4;
ob3 = ob4; // Assignment Operator

```

The syntax for each is pretty much the same tho.

```c++
Class (const Class &o){
    // Copy Constructor
}


Class& operator = (const Class &o){
    // Assignment Operator
}
```

---
