<h1>Lecture 11</h1>

---

<h3>Collision Resistant Hash Function</h3>

  * Hash funct: length decreasing funct
  * Collision resistant: if you pick h from this function at random, no polytime adversary can find the collision
  * SHA256

---

<h3>SHA256</h3> 

  * h: 256 &rarr; 128
  * Construction:
      - S<sub>k</sub> and P<sub>k</sub> of length 2k
          + like last lecture
      - Side note: merkle hash tree of height L
          + _ F11.1__
          + If the hash function we are using is collision resistant, then the entire merkle tree is also collision resistant.

---

<h3>Why coll-resistant hash functions</h3>

  * Suppose you have an existentially and adaptively secure digital signature scheme
      - Assume collission resistant hash functions exist. (call it h)
  * Then the following scheme is also secure
      - Put h into a public key
      - Sign(h(D))
      - __F11.2__
      - More efficient, because we are only signing the hash, which is smaller
      - Still secure, because the hash of the document is just as secure as the original

---

<h3>Construction</h3>

  * __F11.3__
  * Use first k columns (each of length n) to sign k bits of a document
  * you then create a new public key
  * use the remaining bits in a hash function to sign this public key
      - You must send each generational public key (Pk<sub>i</sub>)
      - This is very probelematic, as the length of the info you have to send grows linearly with the number of documents you sign
  * Solution: use a tree
      - +__F11.4__
      - Create two new public/secret key pairs in each step
      - We can just verify that the path from the root to the child is good
      - Makes it go from a linear growth to a log(n) growth
          + this is more reasonable
      - We can create the secret keys using a PRF, which means that we don't have to remember all of the secret keys, so the whole thing becomes more space efficient

---

<h3>Types of Hash Functions</h3>

  * __F11.5__
  * A universal 1-way hash function can be constructed from any 1-way function.
  * This is all we need
      - Reasoning:
      - Because the public key is random, and an adversary has to find Pk' that hashes to the same thing using the hash function, this fits into the category of the universal 1-way hash win conditions. So, we can uuse a universal one-way function.
          + can be constructed using Naor-Yung construction

---
