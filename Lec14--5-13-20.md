<h1>Lecture 14</h1>

---

<h3>Types of Zero-knowledge Proofs</h3>

  * Perfect Z-K:
      - Conversation between the prover and the verifier is exactly equal to the simulated conversation generated by S<sub>V<sup>&ast;</sup></sub>
  * Statistical Z-K:
      - Conversation between the prover and the verifier is statistically close to the simulated conversation generated by S<sub>V<sup>&ast;</sup></sub>
  * Computational Z-K:
      - Conversation between the prover and the verifier is computationally indistinguishable from the simulated conversation generated by S<sub>V<sup>&ast;</sup></sub>

---

<h3>Dishonest verifier Z-K proof</h3>

  * __F14.1__
  * H is some random permutaion of G<sub>0</sub> or G<sub>1</sub>
  * Simulator has to generate a conversation that is computationally indistinguishable to this conversation
      - should be able to generate *b* with the exact same probability 
  * If *b* is generated using a collision resistant hash function, then we cannot do this -- we have no way of "cooking up" an isomorphism that can result in a specific b, and then finding the inverse of the &pi; transition. 
  * Essentially, then, the simulator has to act as a prover; it cannot do this.
  * But, how *can* we make such an simulator?

---

<h3>Persi Diaconis</h3>

  * __F14.2__
  * We can continually replay portions of the communication that work (that we know how to answer) and if any communications don't work, we keep track of that, rewind and replay withouth this communication
  * Since the randomness is fixed (whenever the verifier requests randomness, we supply the random coin flips, etc), the verifier works as a deterministic algorithm, and so we can repeat the same inputs and expect the same output.
  * The difference between this simulator and the prover is that the simulator can start over and keep track of previous answers, etc.

---

<h3>A bug in this definition</h3>

  * __F14.3__
  * &pi;' maps G<sub>b'</sub> &rarr; H
  * Verifier accepts if, at least once, b' &ne; b
  * Obviously, when the verifier accepts, it find the isomorphism between G<sub>0</sub> and G<sub>1</sub>
      - This is clearly not Zero Knowledge, because the verifier now has learned isomorphism between G<sub>0</sub> and G<sub>1</sub>
  * However, using our current definition, a simulation could efficiently generate such a conversation
      - because we don't tell the prover which b they use, it is not part of the conversation. So any random permutation of G<sub>0</sub> or G<sub>1</sub> can be used to falsify the conversation (since an outside observer would not be able to know which b the verifier sent)
  * So what's wrong with our definition of zero knowledge?
      - we have to include not just conversations that are the same, but also that conversations that are the same *with respect to* the random coin-flips used by the verifier.