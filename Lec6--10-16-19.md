<h1>Lecture 6</h1>

---

<h5>Ocaml static type-checking</h5>

  * OCaml type-checking is conservative, meaning that it makes the worst-case assumptions (that are sometimes wrong)

```ocaml
# if 1 < 2 then "a" else "b";;
-:string="a"

# if "a" then 1 else 2;;
(* This will cause an error, because OCaml expects a bool in the conditional *)

# if 1<2 then "a" else 37;;
(* even though this always evaluates to 1, the 
   if-else block will cause an error *)

# let p = (1,2);;
p:int*int=(1,2)
# let q = 1,"abc",false;;
a:int*string*bool=1,"abc",false
#let unit=();;
unit:unit=()    (* an empty tuple is of the 'unit' type... useful when *)
                (* dealing with functions that have side-effects (kind of *)
                (* like void) *)
```

<h5>Tuples vs Lists</h5>

| Tuples | Lists | 
| --- | --- |
| heterogeneous | homogeneous |
| size is fixed/known | size is unknown |

```ocaml
# [1;"a"]
(* error, lists must be homogeneous *)
# [1;-5;3+7];;
-:int list=[1;-5;3+7]
#[];;
-:'a list=[]  (* This returns a generic type list *)
```
Aside on generic implementation:
  * every object is a 64-bit quantity (in x86-64)
      - represented by a pointer
      - Possible assembly code for a generic type:

```assembly
    id:     movq %rdi, %rax
            retq
    represents 'a -> 'a in some generic ID function
```

---

```ocaml
(* Lisp Translations *)
#let cons (x,y) = x::y;;
cons:'a*'a list -> 'a list = <fun> (* This means there is some 
                                            machine/byte code *)

(* The function above requires the second argument 'y' to be a 
   list *)

(* The natural way to write this in OCaml is the following:  *)
#let ccons x y = x::y;;
ccons:'a -> 'a list -> 'a list
(*         ((      )   (      )) *)
 (* Implied parentheses *)
 (* This is an example of "currying" *)

```
  * In OCaml, every function has only one argument, and if more than one is necessary, curried code is automatically generated
  * currying makes it easy to create partial functions, with the first argument curried. (you can only create partial functions with arguments passed from left to right)

---

```ocaml
# let car x::_ = x;;
car:'a list -> 'a = <fun>

(* this is "syntactic sugar" for th following *)
#let car = fun l -> match l with 
    | x::_ -> x;;
(* Since the second function can potentially match with an empty list,  *)
(* and there is not match case that handles this, it gives a warning *)

# car [];;
(* Runtime error: *)

# let car1 = function
    | x::_ -> x
    | [] -> [];;
car1:'a list list -> 'a list
(* The second matching expression forces it to accept only lists of lists *)

# let gcar d = function
    | x::_ -> x
    | [] -> d;;
gcar:'a -> 'a list -> 'a list
(* This way, you can pass any type of list, but you must also pass a *)
(* default value. *)


```
---

```ocaml
# let rec rev = function
    | [] -> []
    | h::t -> (rev t) @ h;;
rev:'a list list -> 'a list=<fun>
(* because this function calls the @ function with h as an argument, *)
(* it expects h to be alist, and thus the imput to be a list of lists *)

# let rec rev = function
    | [] -> []
    | h::t -> (rev t) @ [h];;
(* This is correct, but slow (O(n^2)) bc it has to copy the head and *)
(* each element of the tail (the @ operator is an O(n) operator) *)

# let rec revapp a = function
    | [] -> a
    | h::t -> revapp (h::a) t
revapp:'a list -> 'a list -> 'a list
(* This function runs in O(n) time, because it only adds one element of *)
(* the reversed list at a time to the list *)
```

