<h1>Lecture 4</h1>

---

<h5> C grammar </h5>

```c
stmt:
    ;
    expr ;  (3;, a=3*b;)
    return expr ; 
    break ;
    continue ;
    goto ID ;
    { stmt-list }
    if (expr) stmt 
    if (expr) stmt else stmt  // Can cause ambiguity
    while (expr) stmt 
    do stmt while (expr) ;
    ...
```

> If statements need parentheses around the expression because, without them, the statments could be parsed in multiple ways This is noted in a footnote of the C grammar
> 

```c
// Ambiguous grammar if removing parents

while (i) ++i;

while i++i; // Ambiguous
```
>do-while is the exception to this

Another instance of ambiguity is the dangling else statement.

```c
if (a<b) if (c<d) a++; else b++;
//       {            } 
//       {                      }
```

To solve this ambiguity, we can do what we did before, and convert the troublesome rule and make it more complex

```c
if (expr) stmt else stmt
// becomes
if (expr) stmt2 else stmt
stmt2

stmt2:
    ;
    expr ;  (3;, a=3*b;)
    return expr ; 
    break ;
    continue ;
    goto ID ;
    { stmt-list }
```

---

OCaml has a similar ambiguity, with matching
```OCaml
match E with 
    | P1 -> E1
    | P2 -> match E with 
        | P3 -> E3
        | P4 -> E4    // ambiguous
```

---

<h5>Abstract vs Concrete Syntax</h5>

| Abstract | Concrete | 
| --- | --- |
| `E -> E + E` | `E -> E + T` |
| `E -> ID` | `E -> T` |
| `E -> (E)` | `T -> ID` |
| - | `T -> (E)` |

"parser generators" / "compiler compilers" (ie bison) take a grammar and output a parser that is unambiguous.

---

Aside: Prolog Operator Declarations

```Prolog
:-op(500, yfx, [+,-]) // yfx is left associative
:-op(400, yfx, [*,/])
:-op(200, xfy, [**])   // xfy is right associative
:-op(200, fy,  [+,-]) // fy is unary
:-op(700, xfx, [=,\=,==,>,<]) // xfx is non associative
:-op(200, yf, [!])

IE a**b**c*d -> (a**(b**c)) * d
```

Similar in C:

```c
if (a<b<c)  -> if ((a<b) <c) // first pair returns 0 or 1
if (a == b == c == d)  -> if (((a==b)==c)==d) // first par returns 0 or 1
```

---


<h5>Internet ReuqestForComment 5322 (Email Grammar)</h5>

Grammar for the Header

message id
```
msg_id = "<"word*("." word)"@"atom*("."atom)">"
word = atom / quoted string
atom = 1*<any CHAR except specials,space,and CTLs>
quoted_string <">*(qtext/quoted-pair)<">
qtext=<any CHAR except "\CR>
quoted-pair="\" CHAR
```

  * Terminals are quoted
  * non-terminals are allowd to have items in them
  * `CHAR` is an ascii character
  * `special`: special characters (`()<>@`, etc)
  * `CTLs`: control characters, etc ie `DEL` (Deletes prev char)
  * star and parentheses  (`*(F)`) represent meta-notation (`F*`)
      - `F/G`: or (`F|G`)
      - `1*F`: one or more instance of the following thing (`F+`)
  * Metanotations are just for convenience; they do not do anything that you couldn't do without them

<h5>ISO Standard for EBNF (Extended Backus-Naur Form)</h5>

  | Syntax | meaning  |
  |---|---|
  | `"terminal"` | 'terminal' |
  | `[ option ]` | 0 or 1 |
  | `{ repetition }` | 0 or more |
  | `( grouping )` | 1 |
  | `(* Comment *)` | d |
  | `A-*` | Repetition (0 or more) |
  | `A-B` | exception (set difference)|
  | `A,B` | concatenation |
  | `A <pipe> B` | or |
  | `lhs = rhs;` | grammar rule |
> the above is in decreasing order of precedence

ISO EBNF (increasing order of precedence)

```
syntax = syntax rule; (* identifiers can have spaces *)

(* meta id ,          defns list        , semicolon *)
syntax rule = meta id , '=', defns list, ';';
defns list = defn,{'|',defn};
defn = term, {',',term};
term = factor,['-',exception];
...
```

