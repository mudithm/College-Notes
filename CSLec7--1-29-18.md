<h1>Lecture 7</h1>

---

<h4>Problems with Linked Lists</h4>

```c++
Node* head;
struct Node{
    int data;
    Node* next;
};
```

Advice for working with new data structures
  * Draw accurate and thorough pictures.
  * Trace through the code carefully, updating the picture as you do it.
  * Draw the empty container, one with one object, one with two objects, and one with several objects.
      - A useful order of implementation:
          + Create
          + Dump (print out the values/pointers in the list)
          + insert
          + get / contains (looks at the list without modifying it)
          + harder functions (erasing, copy constructors, assignment operators, destructors, etc)
      - Until you write destructors/copy constructors/assignment operators, don't perform these actions (copying / assigning)
  * Anytime you use the `->` operator, you must check to make sure that the pointer 
      - has previously been given a value (initialized)
      - is not not `nullptr`
  * Don't do things in the wrong order
      - Advice when creating a new node: set the values in the new node first, if you can
  * Make sure the code works:
      - in the normal case (in the middle of the list)
      - for the empty list
      - at the start of the list
      - at the end of the list
      - for a one-element list

---

Here is an algorithm to find the first node with a `data` value of 42.

```c++

Node* p;
for (p = head; p != nullptr && p->data != 42; p = p->next)
    ;
```

We need both these conditions, one to exit the loop if we find a 42 and another to exit the loop if there is no node with value 42.

>Remember: in an `and` conditional statement, the first ecpression is checked first and subsequent expressions are only checked if the first is true. So, we check whether p is a `nullptr` before we check the value of its data.

Let's add some more functionality to this algorithm: if we find a 42 in the list, we want to add a 36 after it.

```c++
Node* p;
for (p = head; p != nullptr && p->data != 42; p = p->next)
    ;


if (p != nullptr){
    Node* temp = new Node;
    temp->data = 36;
    temp->next = p->next;
    p->next = temp;
}

```

Notice that we have three possible outcomes here--the first is if 42 is somewhere in the middle of the linked list, the second if it is at the end of the list, and a third if it is not in the list. 

This if statement takes care of these cases.

---

Now let's modify the above code to remove a 42. This is going to be a bit more complicated, since our linked list only points in one direction.

```c++
Node* p;
Node* prev = nullptr;
for (p = head; p != nullptr && p->data != 42; prev = p, p = p->next)
    ;
if (p != nullptr){
    if (prev != nullptr){
        prev->next = p->next;
        delete p;
    }else{
        head = p->next;
        delete p;
    }

}
```

We stored the previous node in a secondary variable so that we could keep track of the pointer. To do this, we added a second argument to the end of the for loop, `prev = p`. 
We also have to take care of the __special case__ where 42 is the first node in the list.

---

Let's add another data member to our class that keeps track of the tail pointer of the list (the last one).

```c++
Node* head;
Node* tail;
struct Node{
    int data;
    Node* next;
};
```

This drastically complicates the code we have to write -- now we have to keep track of both the head and the tail, change it when necessary, test special cases, etc. But, it adds useful functionality.

We can remove this special case and keep its functionality by making this a circular linked list. This means that the last element in the list will point to the head.

We can also implement a doubly linked list, with members that point to the previous and the next element in the list.

```c++
Node* head;
struct Node{
    int data;
    Node* prev;
    Node* next;
};
```

But this also adds more special cases. 
We can eliminate some of these by implementing a doubly linked circular linked list, where the `head` points to the last element and the last element points to the `head`.

A final way to set this up, one without any special cases, involves adding a node to the beginning of this circular doubly-linked array called a _dummy node_, one that is always present but has no interesting value.

The tradeoff to the lack of special cases is a more complicated implementation, the robustness might be worth it. The better choice depends on the situation.

---

<h4>Stacks</h4>

A stack is a data structure that only allows insertion and deletion of the last element in the list. It mimicks common program behavior.

__Basic operations:__

  * create an empty stack
  * "push" an item on the stack
  * "pop" an item on the stack
  * Look at the top item on the stack
  * Is the stack empty?
  * -------------
  * Optional
  * -------------
  * How many items are in the stack?
  * Look at any item on the stack

Business people call this a last-in, first out scheme, or a LIFO data structure