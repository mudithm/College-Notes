<h1>Lecture 4</h1>

---

<h4>Scripts</h4>

  * If a script is running for a long time or is caught in an infinite loop and is preventing you from using the shell, you can use `&` to run a process in the background so you retain access to the shell.
  * To kill this process now that you no longer have direct access to it in the shell, you can use the `ps` and `kill` commands

---

<h4>Example</h4>

  * An assignment directory for each lab
  * Before each lab:
      - remove old dir
      - make a new dir called "assgn2"
      - create 3 files in the lab:
          + `lab.log` 
          + `lab.txt` 
          + `hw.txt` 
  * During the development process, you can add the `set -x` to turn on execution tracing. 
      - This can help you debug
      - errors will be stored
      - use `set +x` to end execution tracing 
  * Final submissions should not include these statements, they should only be used during debugging

---

<h4>Output using echo or printf</h4>

  * `echo` writes arguments to stdout
      - needs `-e` option to output escape characters
      - automatically goes to next line after output
      - `echo "Hello\nWorld` would replicate the string exactly 
      - `echo -e "Hello\nWorld"` would include the newline character
  * `printf` can output data with complex formatting (like in `c`)
      - does not automatically go to next line after output
      - `printf "%.3e\n" 46553132.14562253` --> `4.655e+07` 

---

<h4>Variables in scripting</h4>

  * Declared using `=` 
      - `var="hello"` -- No spaces!
  * Referenced with `$` 
      - `echo $var` 
  * Variables are automatically assigned a type: if there is an ambiguity, it will decide on its own what is the best type to use. 
      - So, you should be careful that your variables are not ambiguously typed.
  * Built In Shell variables ([POSIX](http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_05_03))
      - `#`: Number of arguments given to the given process
      - `?`: Exit status of the previous command
      - `IFS`: Internal field separator, the list of characters that act as word separators

---

<h4><code>?</code></h4>

Exit Status: 

| Value | Typical/Conventional Meaning |
| --- | --- |
|  0  |  Command executed successfully  |
|  > 0  |  Failure to execute command  |
|  1-125  |  Command exited unsuccessfully. Depends on the command  |
|  126  |  Command found, but file was not executable  |
|  > 126  |  Command died due to receiving a signal  |

> These error codes should be included in a command's `man` page
> 
---

<h4>Accessing arguments</h4>

  * Command line arguments are represented by positional parameters
      - first argument is `$1`, second is `$2`, etc.
      - After the first 9, enclose the number in curly braces
          + `$10` 
  * `$0` holds the name of the script itself. Used primarily for debugging and for error messages

---

<h4>If Statements</h4>

  * In shell, `if` is also a command
  * `if` statements use the `test` command

```shell
    #!/bin/bash

    if [ 5 -gt 1 ]
    then
        echo "5 greater than 1"
    else
        echo "This will never happen"
    fi
```

> Make sure you include the spaces after `if` and surrounding the braces, or else you will get a strange syntax error
> 
  * `fi` signifies the end of the `if` statement's scope

Comparisons:

| symbol | meaning |
| --- | --- | 
| -gt | greater than |
| -ge | greater than or equal |
| -lt | less than |
| -le | less than or equal |
| -ne | not equal |
| -eq | equal |

A `!` can be used to negate one of the operands of the comparison:

`if [ ! $1 -gt 0 ]`

A stupid example:
```shell
    #!/bin/bash
    if [ $? -gt 0 ]
    then
        echo "Command made an error"
    elif [ $? -eq 0 ]
    then
        echo "Command ran successfully"
    else
        echo "not sure"
    fi
```

To combine comparisons in `if` statements: 
    `&&` for and, `||` for or

---

<h4>Quotes</h4>

  * Three kinds:
      - Single Quotes `''` 
          + Do not expand at all, literal meaning
          + Everything acts like just characters, not commands, etc.
      - Double Quotes `""` 
          + almost like single quotes, but expand backticks (` `` `) and `$`
      - Backticks ` `` ` or `$()`
          + Expand as shell commands
          + When a variable in backticks is declared, the command within will be run and its output will be saved __*as a string*__
```shell
    temp=`ls` ; echo $temp
```
> The above code will echo the output of the ls command, since the `ls` is surrounded by backticks

> 
Bash scripting heavily favors strings -- at the first opportunity, it will try to convert integers to strings. For example, the following examples all result in strings

```shell
    num=5
    echo $num
    
    # As soon as it is passed to echo, num is treated like a string.
    #  ------
    
    num=5
    var=$num+1
    # this will result in a string "5+1"
```

---

<h4>While loops</h4>

```shell
    #!/bin/bash
    COUNT=6
    while [ $COUNT -gt 0 ]
    do
        echo "Value of count is: $COUNT"
        let COUNT=COUNT-1
    done
```

