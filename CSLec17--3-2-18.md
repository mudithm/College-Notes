<h1>Lecture 17</h1>

---

This was a friday lecture, so it was p chill and laid back. Talked about sorting algorithms and trees.

---

<h4>Trees</h4>

  * They are p cool
  * good for modeling hierarchical stuctures

<h4>Characteristics</h4>

  * Nodes
      - each individual element of the tree
  * Edge
      - Connection between nodes that are parent and child
      - Closer to the root is the parent
  * Path
      - Connection between any two nodes in the tree
  * Root
      - The first node, that is the base of the tree
      - A characteristic of the tree is that there is _exactly_ one path between the root and any other node in the tree. (ie they cannot have loops)
  * subtree
      - p self explanatory tbh. part of a tree that can sort of be treated as its own tree
  * Leaf nodes
      - nodes that have no children
  * Interior nodes
      - everything else in the tree
      - has at least one child (includes the root node)
  * Depth:
      - how many edges away from the root (root is at depth 1)
  * Height of tree:
      - maximum depth of the tree


Getting into the implementation:

```c++

// Header file
void printTree(const Node* t, int depth=0);


//Implementation file
struct Node
{
    string data;
    vector<Node*> children;
};

// Counts the number of nodes in the tree (or a subtree)
int count(const Node* t)
{
    if (t == nullptr)
        return 0;
    int total = 1;
    for (vector<Node*>::iterator iterator = children.begin(); iterator != children.end(); iterator++)
        total += count(*iterator);
    return total;
}

void printTree(const Node* t, int depth)
{
    if (t == nullptr)
        return;
        // The following line makes use of a feature of the string class
        // that takes a number of times to be repeated and a character 
        // to repeat. 
    cout << string(2 * depth, ' ') << t->data << endl;
    for (vector<Node*>::iterator iterator = children.begin(); iterator != children.end(); iterator++)
        printTree(*iterator, depth+1);
}

```

Two main types of these recursive operations

  1. Pre-order traversal: process the current node BEFORE processing the subtrees
  2. Post-order traversal: process the current node AFTER processing the subtrees

The printTree is a pre-order traversal, but the count function is kind of ambiguous as to the type of traversal.

---

Another implementation without dynamic allocation: the Binary Tree

```c++
struct Node
{
    string name;
    Node* oldestChild;
    Node* nextYoungerSibling;
}

// Although it may look similar, a binary tree is NOT a doubly
// linked list. The nodes do not point to their parent nodes, 
// only to children.
```

