<h1>Lecture 5</h1>

---

<h3>Hardcore bit</h3>

  * __F5.1__
  * We say that H is a hard-core bit if no PPT Adversary can win this game
  * Golreich, Levin
      - The dot product is a hard-core bit (for us, for any one-way permutaion; for them, any one-way function)
      - Proof: if f is a one-way permutation, then dot product is a hardcore bit
      - __F5.2__
      - Proving by contrapositive
      - We assume t/w contradiction that there is some adversary that can solve the hardcore bit, show it could bbreak some 1-way functin, show this is a contradiction bc 1-way permutation is impossible to invert in poly-time
      - Idea is to torture the 1st adversary model to get Adv' that can efficiently output the correct bit
  * __F5.3__
  * If we have an adversary that can always guess the hardcore bit, how can we break/invert the one-way function?
      - If the adversary is right no matter the input, can use the random string 1000000000, meaning that the dot product `<x, r>` will always be the first bit of x
      - repeat this process for all strings (0100000, 00100000, etc) to get the entire x
  * __F5.4__ 
  * If we have an adversary that can guess the hardcore bit with probability (3/4) + &epsilon;, how can we break/invert the one-way function?
      - CLaim: if both b and b' are correct, b &xor; b' = x<sub>i</sub>
      - Since if we add the same bit twice, it get cancelled, the only bit that is added only once is the one we switched between the two trials. Therefore, that is the only one that will not be cancelled by xor. So , the result should just be x<sub>is</sub>
      - NOTE: &xor; &equiv; &Sigma; mod 2
      - Now moving onto the 3/4 + &epsilon; adversary
      - __F5.5__, __F5.6__

---

<h3>Pseudo-Random Generators (PRG's)</h3>

  * __F5.7__
  * Kolmogorov Complexity of string S
      - Shortest pogram (in "C") that outputs S
      - Considers all "short" C programs, where short means it can be described by, say, root(n) bits
  * If the magnitude of the string is n, then there are 2<sup>root n</sup> short functions, and 2<sup>n</sup> total strings of length n.
  * So, 2<sup>n</sup> - 2<sup>root n</sup> strings CANNOT be explained by short programs.

---

<h3>"Turing Test" for intelligence</h3>

  * __F5.8__
  * Tuing test -- if no human can tell the diff between a computer and a human, the computer passes the turing test for intelligence.
      - Computer: Exp 1
      - Human: Exp 2
  * Poly-time Judges
      - Exp1: n bits truly random string
      - Exp2: n-bits pseudo-randomly gen'd string, from short seed s
      - PRG is secure if no poly-time judge can tell the diff with prob >= 1/2 + &epsilon;
          + ie, if it predicts 1 with prob a for exp 1, it should predict 1 with pretty much the same prob for exp
  * For the example PRG
      - F(x) is random, r is random, and `x, r` is a hardcore bit that looks random for any adversary
