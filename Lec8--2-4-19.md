<h1>Lecture 8</h1>

---

<h4>First-come First-serve Timing Stuff</h4>

  * Average wait time: `5.5 + 1.5(delta)` 
      - `delta` is the context switch time
  * Average turnaround time: `10.25 + 1.5(delta)`
  * Average turnaround = `(avg wait) + (avg run)` 
  * Pros:
      - High utilization
  * Cons:
      - Long Job can make others wait (convoy effect)
      - Harder to do IO in parallel

---

<h4>Alternative: Shortest Job First</h4>

  * jobs are done in order of how long they will take
  * Pros:
      - faster average wait times
  * Cons:
      - unfair: shorter jobs take priority
          + no guarantee that long jobs will ever execute
          + `starvation` 

---

<h4>Another Alternative: Round Robin Approach</h4>

  * Assumes Pre-emption (fcfs + pre-emption)
  * Pros:
      - Faster wait times than fcfs
  * Cons:
      - more context switches, adds to avg turnaround time

---

<h4>Priority of jobs</h4>

  * __statically assigned:__ job's priority is known as part of scheduling problem
  * __dynamically assigned:__ can change with time
  * __externally assigned:__ user, operator set
  * __internally assigned:__ (set by scheduler)
  * Niceness: used in the Linux scheduler. The nicer a process is, the lower its priority.
      - Superset of first come first serve
      - linux command `nice <int>` 
          + negative integer increases niceness (i think)
          + positive integer decreases niceness (i think)
  * FCFS: priority = arrival time
  * SJF: priority = run time
  * Linux: prioity = niceness + timestamp of the last time you ran

---

<h4>Realtime Scheduler</h4>

  * Hard Real time:
    - if your program misses deadline, its wrong
    - predictability trumps performatnce (disable caches, etc)
    - disable interrupts, do I/O via polling
  * Soft Real time:
    - an occasionally missed deadline is not a bug
    - some example schedulers:
      + earliest deadline first
      + rate-monotone scheduler(assign higher priorities to more frequent tasks)

---

<h4>Defense against Race Conditions</h4>

  * Load and store very carefully
  * Assumption that you can make sometimes: 
    - loads/stores are atomic (NOT true)
    - two stores simultaneously: one wins
    - load+store simul:load gets old or new value
    - access to nearby memory works the same way

---


<h4>Goals of synchronization</h4>

  * Coordinate acatinos in a shared address space
  * maintain data consistency
  * do so efficiently
  * do so clearly + simply + reliably