<h1>Lecture 2</h1>

---

<h4>Functional Programming iRL</h4>

<h5>Big Backend Queries at Google</h5>
  * Map Reduce (Parallelizable)
  * came from functional programming Lisp ML Haskell

<h5>Jane st Capital -- speed is everything</h5>
  * High-speed trading
  * Had to write and maintain rapidly evolving code
      - evolved due to competitive pressure
  * Metaprogramming
      - automating some of the task
      - you write a program to generate the other program
      - This process was hard to use
          + Solved with functional programming
              * used to generate functions
      - They also wanted good static analysis of their code to catch errors before the code run
          + OCaml provided both these features
          + Type inference (compile/link time, not runtime like Python/JavaScript)
          + static analysis ensures that certain issues are guaranteed to not have certain issues, so we don't need to check for them in runtime

---

| Language Category | pg | Unit of Computation | combination | ex |
| --- | --- | --- | --- | --- |
| imperative | C, C++, Java, Python | Command | S1, S1 sequencing | `a = b + 1`|
| functional | Lisp, ML, Haskell | Expression | function calls | `f(g(x), h(y))`|
| logic | Prolog | assertion | `& | ->`, etc |

> There aren't super sharp lines between each of these categories; a lot of imperative languages take aspects of functional programming, etc

---

<h4>Functional Languages -- Motivation</h4>
  * Fortran (J Backus)
      - Contributions to Functional Languages:
          + Clarity
              * In imperative languages, code is often hard to read and hard to follow 
                  - i.e. `i = i + 1`
              * We should use the already existing mathematical notation, not abuse
                  - i.e. integration: integral is a function that acts on functions (takes functions as an argument)
                  - `functionals`: function with a function as an argument
          + Parallelizability
              * Programs written in functional notation are much easier to parallelize in the compilation/runtime steps; this is often very difficult for imperative languages

---

<h4> Definitions in Functional Programming </h4>

  * `Function`: mapping from a domain to a range
  * `funtional form`/`higher-order function`: either the domain or the range includes functions
  * `evaluation`: order is given by pattern of calls. way of determining what single value a set of expressions stands for
      - i.e. `f(g(x), h(i(y), z))` 
      - There is still some sequencing in this approach (typically, in the above case, `i(y)` would be evaluated before `h` begins)
      - No `;` (no sequencing)
      - No `=` (no assignment statements)
          + You can't change your mind about what a variable is
          + kind of like putting `const` in front of every local variable
          + `referential transparency`: You don't have to worry about other functions changing the value a variable refers to
              * helps both clarity and performance
                  - compiler can cache the value of variables into a register

---

<h4>Syntax</h4>

  * `Syntax`: form independent of meaning (`semantics`)
  * Why syntax now?
      - it's easier
      - it made us respectable
  * "Colorless green ideas sleep furiously"
      - Noam Chomsky
      - Syntactically correct, but semantically nonsense
  * "Ireland has leprechauns galore."
      - Paul Eggert
      - Syntax is a bit squirrely, but the semantics are clear
  * "Time flies."
      - ambigous meaning, as "time flies" can be imperative or descriptive
      - In programming languages, ambiguity is normally seen as a flaw
      - Example: `a = b + c + d` , all doubles
          + The order of the operations is variable, and so there might be small differences based on rounding depending on the order in which the expressions are computed

<h5>Syntax Choices</h5>
_Reasons to pick on syntax over another_

  * `a = b + c` vs `a := b + c`; 2nd example distinguishes between assignment and equality
  * Inertia
      - you want to pick a syntax that is familiar to people
  * Simple and Regular  
      - you want the syntax that is simplest and most straightforward
  * Readability
  * Writability
      - negative example: APL
  * Redundancy
      - want a language that makes you repeat yourself at least a little bit (i.e. curly braces, etc)
  * Unambiguous

<h5>Syntax Description</h5>

  * Tokens (i.e. categories of lexemes)
      - Building blocks of the syntax
      - Character set (ASCII, Unicode, etc)
          + ASCII: 7-bit, leading bit is 0
          + Unicode
              * if leading bit 0, treat like ASCII
              * if leading bit 1, use UTF-8 addressing
      - Empty lines/comments -- generally not considered tokens
      - `keywords`: tokens that look like identifiers, but they are not
          + usually also reserved words, but not always
              * issues can arise when new keywords are added in future iterations of languages