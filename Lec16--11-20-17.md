<h1>Lecture 16</h1>

---
```c++
    void celebrateBirthday(Employee& e){
        e.age++; //increments the age of a struct object Employee
    }

```

Another implementation:

```c++
    void celebrateBirthday(Employee* ep){
        *ep.age++; // Flawed: '.' has higher precedence than * 
    }

```

This code will not work as intended, as the compiler will try to find `ep.age` before it follows the `*` to the employee object

There are two possible solutions to this problem. The first is somewhat inelegant, but functionally sound:

```c++
    void celebrateBirthday(Employee* ep){
        (*ep).age++; // Fixed 
    }

```

The other solution introduces a new operator, the `->` operator, which takes in a pointer and one of the attributes of the object it leads to. In practice, it looks like:

```c++
    void celebrateBirthday(Employee* ep){
        ep->age++; // Fixed 
    }

```

---

A problem with the above functions, and one that is somewhat common, is that both could accept a null pointer as an input. For this reason, it is more common to use the first definition and pass by reference, since there will at least not be any undefined behavior.

---

```c++
    double totalPayroll(const Employee emps[], int nemps){
        double total = 0;
        for (int k = 0l k < nemps; k++)
            total += emps[k].salary;
        return total;
        
    }

    void printPayCheck(Employee emp){
        cout << "Amount: " << emp.salary << endl;
        cout << "Pay to the order of " << emp.name <<endl;
    }

    int main(){
        Employee company[100];
        int nEmployees = 0;
        
        // ...
        // read info, fill array, set nEmployees
        // ...
    
        printPayCheck(company[2]);
        celebrateBirthday(&company[1]) // or celebrateBirthday(company + 1);
        cout << totalPayroll(company, nEmployees)
    }
```

This is an example of how the functions could be used in a program.
    
---

```c++

    // A function that keeps track of the position and history of a moving
    // object. Rs and Ls represent left and right movements.
    //    ^ THIS alone is not enough!
    // pos == number of Rs in history - number of Ls in history

    struct Target{
        // Invariant:
        // history consists of only Rs and Ls

        int pos;
        string history;
    }; // again, don't forget the semicolon

    int main(){
        Target t;
        t.pos = 0;

        //...

        t.pos++;
        t.history += 'R';
    }
    

```

Adding invariants to the functions/variables in your code can help you keep track of program requirements when working on large projects and/or in groups.

A way to make these concrete, ie ensure that the values cannot be assigned in a way that ruins their alignment, you can make functions that do those tasks for you.

This will introduce a new type of function declaration.

For example:

``` c++
// Amending the struct Target

struct Target{
        // Member functions
        void init();
        void move(char dir);

        // Invariant:
        // history consists of only Rs and Ls

        int pos;
        string history;
    }; // again, don't forget the semicolon

// This function definition links the init function to 
// the Target structure
void Target::init(){
    // The this refers to the pointer to the object that
    // the function is called on
    this->pos = 0;

    //Remember, this is a pointer to the object.
}

bool Target::move(char dir){
    switch(dir){
        case 'R':
        case 'r':
            this->pos++;
            break
        case 'L':
        case 'l':
            this->pos--;
            break;
        default:
            return false;
    }
    this->history+=toUpper(dir);
    return true;
}

int main(){
        Target t;

        t.init();
        t.move('R');
        t.move('R');
        t.move('L');
        
        Target t2;

        t2.init();
        t2.move('R');
        t2.move('R');
        t2.move('L');
        


}

```

These functions are known as member functions, and they have certain priveleges that normal functions do not. 

Member functions declare like the functions above automatically receive a pointer to the object they are called on. Take note that `this` is a pointer, and thus requires the `->` operator to access its attributes.

---

To ensure that only certain functions can modify certain values in the struct, use the public and private flags.

For example:

```c++
    // ...
    struct Target{
        
        public:
            // Member functions
            void init();
            void move(char dir);

        // Invariant:
        // history consists of only Rs and Ls
        private:
            int pos;
            string history;
    }; // again, don't forget the semicolon
    // ...
```

In this way, we limit access to these variables to the member functions, which have access since they are within the structure declaration.