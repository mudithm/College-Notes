<h1>Lecture 3</h1>

---

<h4>Problems w/ standalone programs</h4>

  * __Avoiding Duplication of code__ 
      - `read_ide_sector:` (among other functions) is duplicated amongst all the programs (BIOS, MBR, OS, GRUB, etc)
      - Hard to maintain
      - wastes cache
      - To attack this problem:
          + Put the copy in ROM and use that
              * very hard to update
              * can lead to low performance(will not be tailored for specific devices, may be out-of-date, needs to work for all, has to be conservative, etc)
          + Put one in ROM and one in RAM
              * Have everything use the copy that is in RAM
                  - use the ROM for boot process, the RAM during execution
                  - Where do we put it?
  * __Changing the code to do I/O and Computeation at the same time (double buffering)__
      - ie counting while doing I/O. (read a chunk, and count while waiting on the I/O to execute)
      - Simple computation (eg counting): computational tasks happen much faster than I/O operations. Bottlenecked by read speed
      - Complex computtaion (eg cracking passwrods): Computational tasks are slower than I/O operations. Bottlenecked by compute power.
      - Ideally, the amount of CPU time it takes to process a bufer is the same as the amount of time it takes to read a buffer. This will lead to near perfect parallel scaling. (about half the time for the same result)
      - Goal: achieve double buffering without rewriting all the apps that rely on old behavior
  * __Programmed I/O__
      - Normally, data goes from I/O devices into the CPU and then into the RAM
      - To improve performance, use DMA -- when the data is in the controller and needs to go to ram, the data goes straight from the disk controller to the ram. (does not have to pass through the CPU)
      - Again, this change would force us to make changes to ALL our software
  * __Running several programs in parallel (Multitasking)__
      - Possible with standalone programs, but would require each program to know the memory location of all others.

What we want:

1. Run several tasks with a simple API that we don't have to change. (or at least not very often)
2. Reuse parts of applications
3. Multitasking without rewriting
4. Recover from faults easily

---

<h4>Complexity</h4>

  * Modularity
      - Have more modules/tasks, but each is so much simpler than the whole that the overall system is simpler
  * Abstraction
      - Have "nice" boundaries between modules
      - EX: a good API for blocking input
          + What we Have: 
          + `void read_ide_sector(int sectorno, char *buf*)`   
              * _Problem:_ assumes that you only have one device
              * _Solution:_ add a device number
              * _Problem:_ do way to tell if/why a read failed
              * _Solution:_ return an error code
              * **Note: only using blocking input (not double buffering, etc.)
              * _Problem:_ assumes 512 byte sector size
              * _Solution:_ specify how many bytes we want read, and use byte addresses instead of sector addresses
              * _Problem:_ the last change means an `int` is no longer sufficient to access all data (only 2 gigs for 32 bit). So, we use the `off_t`  type for the address, and the `size_t` type for the number of bytes.  This would help ensure that the addresses and sizes are appropriately limited for the specific device (32 bit, 64 bit, etc)
          + The new interface:
          + `int read_sector_modified(int deviceno, off_t byteno, char *buf, size_t nbytes)`
          + POSIX function:
          + `size_t read(int d, char *buf, size_t nbytes)`
              * The POSIX API keeps track of the current location, so the `byteno` parameter is not needed. Additionally, instead of using a `deviceno`, it uses a file descriptor `fd` which can represent a drive, a file, a network link, etc.
              * It also removes the offset parameter because it assumed the devices in question were storage devices and not others.
              * This allowed for the use of pipes
              * the `lseek(int fd, off_t where, int flag)` can find a specific location on a disk (for block reads that require specific byte/sector locations rather than based on the previous read). It can be used in conjunction with (read) to perform reads like the function we defined. (it sets the read location to whatever place is passed into the parameters)
                  - Reading the 1000000000th byte:
                  
                  ```c
                  if (lseek(0, 1000000000, SEEK_START) <= 0) // checks for null
                      error();
                  if (read(0, &buffer, 80) < 0)
                      error();
                  //more code

                  ```
                  - the pread function combines `lseek` and `read`

---

<h4>2 Major types of devices</h4>

  * Storage devices (flash, disk, etc)
      - big array of blocks
  * Stream devices (network interfaces, mouse/keyboard)
      - send or receive data
  * We also have pipes.

---

<h3>How to <b>do</b> OS APIs </h3>

<h4>Soft Modularity (voluntary modularity) </h4>
 
  * C: modules
      - modularizes code
  * C++: classes
      - moduralize code + data
  * One big happy object-oriented program
      - Problem: works fine for small-scale OS, but does ont scale well to larger OS (bugs tend to cascade, and cause the whole system to crash)
      - We need to ensure that a failure in one module does not crash the others

<h4>Hard Modularity (Enforced Modularity)</h4>

  * 3 fundamental system abstractions
      - Memory API
          + `write(addr, value)`
          + `value = read(addr)`
      - Link API
          + `send(linkname, outgoing data)`
          + `receive(linkname, incoming data)`
      - Interpreter API
          + instruction pointer: what instruction will be executed next
          + environment pointer: missed this so IDRK
          + repertoir: set of operations that an interpreter can execute
          + Combine to form a more complex API

<h4>How to achieve hard modularity</h4>

  * Client/Service organization
        - 
          uses Link API to communicate. That way, no client program can affect the data, instructions, etc of the service program except through the link. (enforced isolation)
          + Can improve parallelism (two can act independently)
          + Cons:
            * More expensive to run
            * more of a hassle to set up

  * Virtualization
    - Protecting service from "client" by running "client" in a virtual machine
    - write an interpreter (in C) for x86-64

    ```c
    long q;
    char program[1000000000];
    switch(program[ipH]){
      case ...
    }
    // check each instruction to see if it tries to do something wrong
    ```

    - QEMU does this
    - very slow, since it has to look through each instruction

---

<h4>Hardware-supported Virtualization</h4>

  * Protected Transfer of Control
  * Requires at least 2 CPU states
    - User and Kernel
      + Some instructions activate a trap (are treated as an invalid instruction)
        * the trap type is used as an index into the interrupt service vector, which contains pointers to code to be executed for each trap. This occurs on the hardware level (and in kernel mode).
      + Traps transfer you into kernel mode
    - All the trap code is held in protected memory and managed by the operating system.
    - Trap pushes the following onto the stack:
      + ss        state segment
      + rsp       stack pointer
      + rflags    flags
      + cs code   segment
      + rip       instruction pointer
      + code 
    - The kernel/OS then decides who to pass control to (back to you, to another process, etc.)
    - Can also make a system call.

Example of a system call:

```c

read (fd,something, 0)

int 128
//this is a privileged instructino, but iby convention it is treated as a system call attempt by the kernel.s The kernel will decide whether or not the instruction will be called.
