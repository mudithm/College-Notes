<h1>Lecture 11</h1>

---

__Logic Programming:__ Prolog
__Reflection:__ Scheme

---

<h5>Propositional logic</h5>

  * Propositions: truth-valued statememnt about world
      - "it's raining at UCLA"
      - "the 405 is busy"
  * Connectives: logical operators tha operate on statements
      - AND
      - OR
      - NOT
      - IMPLIES
      - REVERSE IMPLIES
      - IFF
      - tautology: statement that is always true
          + these don't give us any useful information

![connectives](https://cdn.discordapp.com/attachments/581226308672159747/644299517751197733/20191113_141513_HDR.jpg)
![truth table](https://cdn.discordapp.com/attachments/581226308672159747/644299518829002757/20191113_141537.jpg)

---

<h5>Socrate's Death</h5>

  * All men are mortal
  * Socrates is a man
  * therefore, Socrates is mortal
  * Syllogism
      - NOT proveable with propositional logic
      - propositional logic isn't powerful enough to represent this kind of logic.

<h5>First Order Logic (Predicate Calculus)</h5>

  * Logical Variables (X, Y, Z)
  * quantifiers &forall;, &exist;
  * &exist; X p(X) &harr; &not; &forall; X &not; p(X)
  * You can't algorithmically check for tautologies in general, but we want to reason as much as we can.
  * Causal Form (of a formula):
      - standard form for any predicate calculus statement
      - B1 &or; B2 &or; B3 &or; ... &or; Bn &larr; A1 &and; A2 &and; A3 &and; ... &and; An
          + Ai, Bi are preicates &sube; args

<h5>Example</h5>

  * &forall; X
      - dog(X) &or; cat(X) &or; pig(X) &larr; licensed(X) &and; in_santa_monica(X)

These are still very difficult to prove automatically in a general sense; so, to simplify, use horn clause

---

<h5>Horn Clauses</h5>

  * Simpler clause forms for n &le; 1
  * single or no consequent
  * 3 main styles:
      - n=1, m=0
          + dog(X)&larr;
          + &forall; X (dog(X))
          + facts, in prolog
      - n=1, m &ge; 1
          + dog(X) &larr; canine(X) &and; friendly(X)
          + rules, in prolog
      - n=0
          + false &larr; dog(X) &and; wagging_tail(X)
          + essentially, there are no happy dogs.
          + query, in prolog

---

<h5>Proof by contradiction</h5>

  * Prolog's modus operandi
  * To prove P, assume &not; P, and then prove 'false'
      - find a contradiction
  * Prolog interpreter negates the goal, and finds logical consequences of that negation
      - ?- dog(X),wagging_tail(X)       &not;dog(X);&not;wagging_tail(X)
      - if no, then Prolog couldn't find a contradiction that verifies that the negated goal is false.

---

<h5>Scheme (Lisp -- AI)</h5>

1. Simple
2. Programs are Data

>aside: higher-order functional programming (OCaml): more ways to glue together code

Basic Overview: Properties

  * Scheme is (kind of) an Object Oriented language
  * objects are dynamically allocated and never freed
      - garbage collector
  * types are latent, not manifest
      - latent: associated with an object -- not there until the program is run (not obvious by reading the code)
      - manifest: associated with bits of code
  * Static (lexical) scoping (unlike Lisp)
  * call by value
  * objects include the usual stuff (numbers, strings, etc), + functions (procedures)
      - including continutations
  * very simple syntax, where programs have straighforward representation as data
      - (a b c) represented as linked list, a &rarr; b &rarr; c
  * tail recursion optimization is required
      - if the very last thing a function does is call another function, then the system is required to adjust stack space as required
  * high-level arithmetic
      - no integer overflow
          + downside: slower calculations

---

<h5>More Scheme</h5>

Let and Lambda

```scheme
(* 3 4) => 12
(let ((x 5)(y 7)) (* x (+ y 3)) )
;    is equivalent to 
(lambda (x y)(* x (+ y 3)))
```

Named Let

```scheme
(define (reverse l) 
  (let revapp ((m l)(a () ))  ;args, initial values
  ;body
  (if (null? m)
      a
      (revapp (cdr m) 
        (cons (car m) a))))

; cons creates a pair
; cdr, car take pairs apart

; this is defined by default, but we can write it as
(define (null? x) (eq? x ()))
```

>aside: truth in scheme. #f is false, everything else if true.