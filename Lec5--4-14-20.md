<h1>Lecture 5</h1>

---

<h3>Agenda</h3>

  * Regular Expressions
  * Intro to Context-Free Grammars
  * Generalized NFA (GNFA)
  * Pumping Lemma for FSLs
  * Classes/Families of Languages and Closure Properties (time permitting)

<h3>Class Grading</h3>

  * Midterm on Thursday, week 5 (on syllabus)
  * Midterm on Thursday, week 7
  * In the final exam slot, Final Exam

--- 

<h3>Recap</h3>

  * FSLs = {all languages accepted by a DFA}
  * FSLs = {all languages accepted by an NFA}
      - Both DFAs and NFAs are ways of representing patterns in some way
  * Regular Expressions = "pure pattern"
    - not in any way imperative -- don't tell you HOW to recognize a language, or what the strings in a language are, but are one way of representing the pattern of the strings in a language
      + All three of these representations are equivalent of eachother

<h3>Regular Expressions</h3>

  * R is a regular expression if R is
    - a for some a in the alphabet &Sigma;,
    - &epsilon;,
    - &empty; (empty language),
    - (R<sub>1</sub> &cup; R<sub>2</sub>), where R<sub>1</sub> and R<sub>2</sub> are regular expresions,
    - (R<sub>1</sub> &compfn; R<sub>2</sub>), where R<sub>1</sub> and R<sub>2</sub> are regular expresions, or
    - (R<sub>1</sub><sup>*</sup>), where R<sub>1</sub> is a regular expression

<h3>Recursive Definition over &Sigma;</h3>

| ... | Regular Expression -- Sequence of Math Symbols (Syntax) | Denotes -- The meaning of the symbols (Semantics) |
| --: | :-: | :-- | 
| Basis Cases: | | |
| 1. For all a &isin; &Sigma;, | a | {a} |
| 2.  | &epsilon; | {&epsilon;} |
| 3.  | &empty; | {} |
| Recursive Cases: | If R & S are Regular Expressions, then so are: | |
| 4.  | (R &cup; S) or (R + S) | (Set denoted by R) &cup; (Set denoted by S) |
| 5.  | (R &compfn; S) or (R &sdot; S) | (Set denoted by R) &compfn; (Set denoted by S) |
| 6.  | R<sup>&ast;</sup> | (Set denoted by R)<sup>*</sup>|

---

<h3>Regular Expression Examples</h3>

  * &Sigma; = {0, 1}
  * {all even length strings} = ((0 &cup; 1)(0 &cup; 1))<sup>*</sup>
  * {no two 1's adjacent}=0&ast;(100&ast;)*&sdot;(1&cup;&epsilon;)

<h3>Context-Free Grammars</h3>
  * G = (V, &Sigma;, R, S), where
    - V = finite set, &ne; &empty;, "variables"
    - &Sigma; = finite set, &ne; &empty;, "terminals" (same as alphabet)
      + V &cup; &Sigma; = {}
      + S &isin; V, "start variable"
    - R = finite set of Rewriting Rules, of the form:
      + A &rarr; &beta;  A &isin; V, &beta; &isin; (V &cup; &Sigma;)*
        * RHS (&beta;) is any string of variables
      + Usually written as follows:
        * R: S &rarr; SS | (S) | ()
          - three rules, S goes to SS, S goes to (S), S goes to ()
   
<h3>Example Grammar</h3>

  * G = ({S}, {`(`, `)`}, R, S)
    - R: S &rarr; SS | (S) | ()
  * We begin with S and apply one of the rules to some variable in each step
    - <u>S</u> &rarr; (<u>S</u>) &rarr; (())
    - No more variables, so we are done
  * More examples
    - <u>S</u> &rarr; <u>S</u>S &rarr; ()<u>S</u> &rarr; ()()
    - <u>S</u> &rarr; S<u>S</u> &rarr; <u>S</u>() &rarr; ()()
      + Got to the same end point through a different "path"
  * These examples are called Derivations
    - <u>S</u> &rarr; <u>S</u>S &rarr; <u>S</u>SS &rarr; &rarr; ()<u>S</u>S &rarr; ()()<u>S</u> &rarr; ()()()
      + Leftmost Derivation
    - <u>S</u> &rarr; S<u>S</u> &rarr; SS<u>S</u> &rarr; &rarr; S<u>S</u>() &rarr; <u>S</u>()() &rarr; ()()()
      + Rightmost Derivation
    - you can also, obv, take a path that is neither the rightmost nor the leftmost derivation
  * Derivations can also take the form of a directed, ordered, K-ary, rooted tree
  * __F5.1__
    - For any given parse tree, there will be a corresponding leftmost derivation, and a corresponding rightmost derivation, and both of these will be unique
  * The goal of a parser for a programming language is for it to be a leftmost derivaiton type thing
  * __F5.2__

<h3>Context-Free Grammars</h3>

  * Came from trying to describe languages using a mathematically-sound basis
  * Represents a class of language much more rich than the finite state language

<h3>Rules</h3>

  * For the rule set R: S &rarr; SS | (S) | ()
    - S &rarr; SS is like iteration
    - S &rarr; (S) is like recursion
    - S &rarr; () is like an End

---

<h3>Sentential form</h3>

  * Sentential Form &isin; {&Sigma; &cup; V}*
  * for sentential forms u, x, v and rule A &rarr; x, we write
    - uAv &rArr; uxv
  * and say
    - "uAv yields uxv"
  * This is for *one* derivation step
  * For zero or more re-writing rules,
    - uAvAabc &rArr;* uxcccAabc
  * we say
    - "uAvAabc" derives uxcccAabc
  * 