<h1>Discussion 10</h1>

---

<h4>How to Review</h4>

  * Look over notes
  * UPE review slides
  * Projects and Solutions (where you did wrong)
  * Practive Exams and LA worksheets, and other practice problems


 <h4>Common Mistakes</h4> 

   * ==
   * ; (afer classes and structures)
   * {} mismatch
   * local variable scope
   * indexing an array out of its range

<h4>More mistakes</h4>

  * Passing by reference/value errors
  * function return values
  * switch statement breaks
  * infinite loops in while loops
  * do while loop structure

---

<h4>cin</h4>

  * reaads in a single int, double, or string, consuming leading spaces or new lines
  * stops when it sess characters not of the desired type or space or new line
  * doesn't go to the next line automtaically
  * cin.ignore(10000, '\n')
      - moves the cursor to the next line

<h5>If statements</h5>

  * pay attention to boundary cases
  * rememer the negation laws for conditional statments.

---

<h4>Array</h4>

  * Must have a fixed size (constant var)
  * it is good practice to keep a variable with the size of the array bc the compiler doesnt know how long it is.

<h4>Constant Parameters</h4>

```c++
    int someFunction(const double d){
        ///something
        return 0;
    }

    int someOtherFunction(double& d){
        //something
        return 0;
    }

```

In the above scenario, you can pass any double into the first equation, but you cannot pass a const variable into the second function.


---

<h4>Array = Pointer</h4>

  * UPE example
  * Can we do ptr[0], ptr[1] ?
      - yes, works like an array
  * what if you do cout << ptr?
      - it will give out the address of the first element of the array
  * cout << arr ?
      - same output as above
  * When a function takes an arraay as input, you can pass in a pointer
  * when a function takes a pointer as input, you can pass in an array

---


<h4>Heap vs Stack</h4>

  * Stack:
      - contains local variables
      - variables are automatically destroyed when the function returns
  * Heap:
      - contains dynamic variables
      - use new and delete to allocate and free the memories
      - variables are not automatically destroyed

<h4>Creating a Heap variable</h4>

  * new and delete
  * Can only access it through a pointer pointing to it

```c++
    itn *iptr = new int;
    //use ptr to accecss heap var
    delete iptr;

    someClass *ptr = new SomeClass();
    //use ptr to access the heap variable
    delete ptr;
```

>In this example, the variable iptr is on the stack, because the pointer itself is a local variable. The integer it points to, however, is on the stack.

  * always track the heap variables you create
  * also, remember to use parantheses when you call a constructor for a class

---


<h4>Delete</h4>

  * what happens when you `delete` a pointer?
      - the object that it points to is deleted, but the address stored int he pointer remains the same
  * Is the value of a deleted ptr `nullptr`?
      - only if the initial value of the pointer was `nullptr`
  * What happens when you set a pointer to `nullptr`?
      - you lose access to the variable that it used to point to, creating a garbage value
  * What if you don't `delete` a pointer pointing to a variable on the heap?
      - you are causing a memory leak, filling memory that can never again be accessed
  * Do you have to `delete` pointers to local variables?
      - no, local variables stored on the stack will be automatically removed from memory
  * What if you dereference a pointer after you `delete` it?
      - A garbage value will be returned
  * Can you change a pointer pointing to a heap variable to point to some ofther heap/local variable or set it to `nullptr`?
      - Yes

>After you delete a pointer, you can set its value to nullptr

---

<h4>Class structure</h4>

  * Remember the syntax
  * Calling functions or getting variables
  * ptr -> SomeFunction();
  * obj.someFunction();

 ```c++
    #include <iostream>
    #include <string>

    using namespace std;

    class SomeClass{
        public:
            SomeClass(); // Constructor
            ~SomeClass(); // Destructor
        private:
            int m_someVar;
    };

    SomeClass::SomeClass(){
        m_someVar = 7; // equivalent to this.m_someVar = 7;
    }

    SomeClass::~SomeClass(){
        // Destructor code here
    }
```
<h4>Class Destructor</h4>

  * The destructor is called whenever a class object is destroyed (when the function returns or the entire program returns if it is on the stack, or when the class object is deleted if it is on the heap)
  * You need a destructor when you have to delete elements in the array

---

Destructor Example:

```c++

    class Pet(){
        // ...
    };

    class Person(){
        public:
            Person();
            ~Person();
        private:
            Pet m_pet;
    };

    Person::Person(){
        m_pet = new Pet();
    }

    Person::~Person(){
        delete m_pet;
    }
```

<h4>Function Overloading</h4>

  * Defining multiple functions with the same name but different parameters is overloading
  * The compiler will choose the function with the given parameters (if one exists)

